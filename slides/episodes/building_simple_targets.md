---
aspectratio: 169
---

# BASIC STEPS WITH CMAKE

## HELLO CMAKE!


:::::::::::::: {.columns}
::: {.column width="50%"}

<!--
    The easiest ...
    We wish to compile the following source code into a single executable
-->

\vspace{.5cm}

```c++
//hello.cpp
#include <iostream>
#include <cstdlib>

int main(){
  std::cout << "Hello World!\n";
  return EXIT_SUCCESS;
}
```

. . .

\vspace{.1cm}

<!--
  Alongside the source file, we need to provide CMake with a description of the operations to perform to configure the project for the build tools. The description is done in the CMake language. 
  We will place the CMake instructions into a file called CMakeLists.txt.
  The name of the file is case sensitive;`

  1. Open a text file with your favorite editor. The name of this file will be
  CMakeLists.txt.
  1. The first line sets a minimum required version for CMake. A fatal error will be
  issued if a version of CMake lower than that is used:
  cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
  1. The second line declares the name of the project (recipe-01) and the supported
  language (CXX stands for C++):
  project(recipe-01 LANGUAGES CXX)
  1. We instruct CMake to create a new target: the executable hello-world. This
  executable is generated by compiling and linking the source file helloworld.
  cpp. CMake will use default settings for the compiler and build
  automation tools selected:
    add_executable(hello-world hello-world.cpp)
  and consequently the dependencies <iostream> are automatically linked
  1. Save the file in the same directory as the source file hello-world.cpp.
  Remember that it can only be named CMakeLists.txt.
-->


```{.cmake style=cmakestyle}
# CMakeLists.txt
cmake_minimum_required(VERSION 3.21)

project(HelloWorld LANGUAGES CXX)

add_executable(hello_world hello.cpp)
```

<!-- 
  Configure: Parse the CMakeLists.txt
             Detect toolchains
             Detect architecture
             Find Dependencies
             Generate Cache
  Generate: Write build tool files 
            Write CMakeCache.txt

  Build: Compile binaries
         Link binaries
         Run Tests
         Pack Artifacts
-->

::: 
::: {.column width="50%"}

\vspace{2.5cm}

. . . 

**Generate $\Rightarrow$ Build $\Rightarrow$ Run**

```{.bash style=bashstyle}
$ cmake -B ./build -S ./hello-world

$ cmake --build ./build 

$ ./build/hello-cmake
```

:::
::::::::::::::

## From a single source file to an executable - CMakeLists.txt

- Every CMake project requires setting the minimally required version(s).
  
  ```{.cmake style=cmakestyle}
  cmake_minimum_required(VERSION 3.12)
  ```

<!-- 
  The CMake language is case insensitive, but the arguments are
  case sensitive

  However, CMake gives no guidance what this version may be, and a lot of projects just take the current CMake version or whatever the IDE is proposing as default. This is a problem, because some platforms don't always provide the latest CMake version, and a lot of trial and error is needed before projects can be used. -> there are tools that can determine the minimal working version of CMake
-->

. . . 

<!-- 
  In CMake, C++ is the default programming language. However, we
  suggest to always explicitly state the project’s language in the
  project command using the LANGUAGES option.
-->

- Define the name of the project as well as the supported languages 
  
  ```{.cmake style=cmakestyle}
  project(HelloWorld LANGUAGES CXX)
  ```
  CMake will set various project-specific variables (`PROJECT_NAME`, `PROJECT_SOURCE_DIR`, ...) and determine the compiler(s) based on the specified language(s)

. . . 


- Add the `hello_world` executable **TARGET** to be built from `hello.cpp`

  ```{.cmake style=cmakestyle}
  add_executable(hello_world hello.cpp)
  ```

<!-- 
  All the above are built-in commands provided by CMake, part of CMake's internal implementation and one of its core commands.
-->


## GENERATE AND BUILD

<!-- 
  We are now ready to configure the project by creating and stepping into a build
  directory
  
  From the programmer's perspective, using CMake through the CLI is a two step process
-->

Using **CMake** through the CLI is a two-step process:


1. **Generate** the build files 
 
    ```{.bash style=bashstyle}
    $ cmake -B ./build -S ./<path-to-CMakeLists.txt>
    ```

2. Run the **build** system
   
    ```{.bash style=bashstyle}
    $ cmake --build ./build 
    ```

## CMAKE WORKFLOW (Unix Makefiles Generator)

```plantuml

top to bottom direction

skinparam ranksep 5
skinparam padding 0

skinparam artifact {
  BorderColor Black
  BackgroundColor LightGold
  FontSize 10
  StereotypeFontSize 8
}

skinparam file {
  BorderColor Black
}

skinparam rectangle {
  BorderColor Black
  BackgroundColor LightGreen
  roundcorner 25
}

skinparam defaultTextAlignment center
skinparam ArrowColor Black
skinparam Arrow {
  Thickness 1
}

folder "hello-world" as Repo  #LightBlue {
  file "hello_world.cpp" as HelloWorld  #LightGold
  file "CMakeLists.txt" as CMakeLists   #LightGold
}


rectangle "CMake" as CMake {
  rectangle "Configure" as Configure #LightGrey
  rectangle "Generate" as Generate #LightGrey
}

folder "build" as Unix #LightBlue {
  file "CMakeCache.txt" as CMakeCache #LightGold
  file "cmake_install.cmake" as CMakeInstall #LightGold
  folder "CMakeFiles" as CMakeFiles
  file "Makefile" as Makefile #LightGold
}

rectangle "Build" as Build 

' Connect the blocks
CMakeLists -down-> CMake :  1
Configure -right-> Generate
Generate -right-> Unix :  OUT
Unix -down-> Build : 2
```


<!-- 
  The generated `Makefile` assumes "Unix Makefiles" as the underlying host-system build tool
-->



## CMAKE WORKFLOW (Unix Makefiles)

<!-- 
  Running cmake . in the same directory as CMakeLists.txt would in
  principle be enough to configure a project. However, CMake would then
  write all generated files into the root of the project. This would be an insource
  build and is generally undesirable, as it mixes the source and the
  build tree of the project. The out-of-source build we have demonstrated is
  the preferred practice.

  Modularity and Reusability: By using cache variables, the CMake scripts can be made more modular and reusable across different projects and environments without needing to change the script contents themselves.
-->

<!--
  The command invokes CMake through its command-line interface (CLI) and specifies the location of the project's top-level `CMakeLists.txt` file (`-S` option) and target build location (`-B` option) where the host default build system will be generated
-->

On GNU/Linux, CMake will by default generate Unix Makefiles to build the project:

**Makefile**
: The set of instructions that make will run to build the project.

**CMakeFiles**
: Directory which contains temporary files, used by CMake for detecting the operating system, compiler and other project specific files.

**cmake_install.cmake**
: A CMake script handling install rules, which is used at install time. (more on this later)

**CMakeCache.txt**
: A set of key-value cache variables used by CMake when re-running the configuration. (more on this later)


## GENERATED TARGETS

The build system generated by CMake (e.g. Makefile) will contain more targets than those strictly needed for building the executable itself

```{.bash style=bashstyle}
$ cmake --build ./build --target help
... all (the default if no target is provided)
... clean
... depend
... edit_cache
... rebuild_cache
... hello_world
... hello.o
... hello.i
... hello.s
```

and can be chosen individually

```{.bash style=bashstyle}
$ cmake --build . --target
```


## More 

For more complex projects, with a test stage and installation rules, CMake will generate
additional convenience targets:
test (or RUN_TESTS with the Visual Studio generator) will run the test suite
with the help of CTest. We will discuss testing and CTest extensively in Chapter
4, Creating and Running Tests.
install, will execute the installation rules for the project. We will discuss
installation rules in Chapter 10, Writing an Installer.

package, this target will invoke CPack to generate a redistributable package for
the project. Packaging and CPack will be discussed in Chapter 11, Packaging
Projects.

## Switching Generators (Ninja)

<!-- 
  CMake is a build system generator and a single CMakeLists.txt can be used to configure projects for different toolstacks on different platforms. 
  You describe in CMakeLists.txt the operations the build system will have to run to get your code configured and compiled.
  Based on these instructions, CMake will generate the corresponding instructions for the chosen build system (Unix Makefiles, Ninja, Visual Studio, and so on).
-->


<!--
  By default, on GNU/Linux and macOS systems, CMake employs the Unix
  Makefiles generator. On Windows, Visual Studio is the default generator

  A single CMakeLists.txt can be used to configure projects for different toolstacks on different platforms. CMake is a build system generator.

  CMake generates the corresponding instructions for the chosen build system.

-->

- For a list of the available generators on your platform inspect the output of

    ```{.bash style=bashstyle}
    $ cmake --help
    ```
 
- To generate Ninja build files, pass the generator explicitly with the `-G` CLI switch

    ```{.bash style=bashstyle}
    $ cmake -G Ninja -S ./<path> -B ./build 
    ```

- The CMake build command wraps the underlying build tool command in a unified, cross-platform interface

    ```{.bash style=bashstyle}
    $ cmake --build ./build 
    ```





# Build Configurations



## Motivation 

Build configuration is a critical aspect of software development, particularly in the context of compiled languages such as C, C++, and Fortran. 

Effective build configuration is crucial for several reasons:

Performance: Properly optimized build configurations can significantly improve the performance of the final product.
Portability: Ensures that the software can be built and run on different platforms and environments.
Debugging and Testing: Different configurations can be tailored for more effective debugging and testing.
Reproducibility: Ensures that builds are consistent and reproducible, which is essential for collaborative development and for maintaining stable production environments.

Understanding and managing build configurations is a foundational skill in software engineering, particularly when dealing with complex systems or when targeting multiple platforms. It is about balancing the needs for development efficiency, performance, and maintainability of the codebase.

## Motivation II
Build Configuration often includes:

Compiler Settings:
Choice of Compiler: Determining which compiler (e.g., GCC, Clang, MSVC) is best suited for the project based on platform, performance needs, or specific feature requirements.
Compiler Options: Configuring compiler flags that affect optimization levels, debugging information, and more.
Build Types:
Development Builds: Often have debugging enabled (more verbose logging, no optimization) to facilitate easier tracing of errors and bugs.
Release Builds: Optimized for performance and may include additional changes like disabling logging or assertions to enhance speed and reduce binary size.
Other specialized builds like Test builds (which might include instrumentation for better testing coverage) or Profile builds (used for performance analysis).
Linker Settings:
Static vs. Dynamic Linking: Deciding whether libraries used in the project should be linked statically or dynamically.
Linker Flags: Customizing how the linker behaves, which can affect the final executable's performance and size.
Platform-Specific Configurations:
Tailoring the build process to different operating systems (Linux, Windows, macOS) or even specific versions or distributions of these OSes.
Configuring builds for different hardware architectures (x86, ARM, etc.).
Optimization Settings:
Setting compiler flags that control optimization levels, such as -O2 or -O3 for GCC and Clang, or /O2 for MSVC.
Other optimizations like link time code generation (LTCG) or profile-guided optimizations (PGO).
Environment Variables:
Using environment variables to influence the build process, such as PATH, LD_LIBRARY_PATH, or specific toolchain variables like CC and CXX for defining the C and C++ compilers, respectively.



## Specifying the compiler

<!--

  CMake is aware of the environment and many options can either be
  set via the -D switch of its CLI or via an environment variable. The former
  mechanism overrides the latter, but we suggest to always set options
  explicitly with -D. Explicit is better than implicit, since environment
  variables might be set to values that are not suitable for the project at
  hand.

  We recommend to set the compilers using the -D
  CMAKE_<LANG>_COMPILER CLI options instead of exporting CXX, CC, and
  FC. This is the only way that is guaranteed to be cross-platform and
  compatible with non-POSIX shells. It also avoids polluting your
  environment with variables, which may affect the environment for
  external libraries built together with your project.

-->

CMake stores compilers for each language in the `CMAKE_<LANG>_COMPILER` variable. This variable can be set in one of two ways:

1. By using the `-D` option in the CLI

    ```{.bash style=bashstyle}
    $ module load intel-oneapi-compilers # just mention the path to...
    $ cmake -D CMAKE_CXX_COMPILER=icpp
    ```

2. [Discouraged] By exporting the environment variables `CXX` (`CC`, `FC`, `NVCC`)
   
    ```{.bash style=bashstyle}
    $ env CXX=clang++ cmake ..
    ```

I am not convinced, there should also be a way to set it in the CMakeLists.txt file for instance when I want to use different compilers...

<!--

  How it works
  At configure time, CMake performs a series of platform tests to determine which compilers
  are available and if they are suitable for the project at hand. A suitable compiler is not only
  determined by the platform we are working on, but also by the generator we want to use.
  The first test CMake performs is based on the name of the compiler for the project
  language. For example, if cc is a working C compiler, then that is what will be used as the
  default compiler for a C project. On GNU/Linux, using Unix Makefiles or Ninja, the
  compilers in the GCC family will be most likely chosen by default for C++, C, and Fortran.
  On Microsoft Windows, the C++ and C compilers in Visual Studio will be selected,
  provided Visual Studio is the generator. MinGW compilers are the default if MinGW or
  MSYS Makefiles were chosen as generators.

  DEFAULTS 

  Where can we find which default compilers and compiler flags will be picked up by CMake
  for our platform? CMake offers the --system-information flag, which will dump all
  information about your system to the screen or a file. To see this, try the following:
  $ cmake --system-information information.txt
  Searching through the file (in this case, information.txt), you will find the default
  values for the CMAKE_CXX_COMPILER, CMAKE_C_COMPILER, and
  CMAKE_Fortran_COMPILER options, together with their default flags. We will have a look
  at the flags in the next recipe.

-->

## Extracting compiler information 

```{.cmake style=cmakestyle}
# CMakeLists.txt 
...
message(STATUS "Is the C++ compiler loaded? ${CMAKE_CXX_COMPILER_LOADED}")
if(CMAKE_CXX_COMPILER_LOADED)
  message(STATUS "The C++ compiler ID is: ${CMAKE_CXX_COMPILER_ID}")
  message(STATUS "Is the C++ from GNU? ${CMAKE_COMPILER_IS_GNUCXX}")
  message(STATUS "The C++ compiler version is: ${CMAKE_CXX_COMPILER_VERSION}")
endif()
```

## Switching the build type



## Controlling compiler flags 

## Setting the standard for the language

## CMake Stages


## How it works


# Creating a library

## Making a library


- `main` is both the name of the executable file generated and the name of the **CMake target** created (we will talk about targets in more depth)
- The source file list comes next, and you can list as many as you'd like
- CMake is smart, and will only compile source file extensions. The headers will be, for most intents and purposes, ignored; the only reason to list them is to get them to show up in IDEs


```{.cmake style=cmakestyle}
add_library(one STATIC two.cpp three.h)
```

- You get to pick a type of library, STATIC, SHARED, or MODULE. If you leave this choice off, the value of BUILD_SHARED_LIBS will be used to pick between STATIC and SHARED.


## Try different compilation settings 

- As you'll see in the following sections, often you'll need to make a fictional target, that is, one where nothing needs to be compiled, for example, for a header-only library. That is called an INTERFACE library, and is another choice; the only difference is it cannot be followed by filenames.

- You can also make an ALIAS library with an existing library, which simply gives you a new name for a target. The one benefit to this is that you can make libraries with :: in the name (which you'll see later). 

Before doing this we should re-fresh on the steps involved in the compilation process

- Swapping compilers 
- Pre-processing flags 
- Linking flags 

## Compiler 

CMake may pick the wrong compiler on systems with multiple compilers. You can use the environment variables CC and CXX when you first configure, or CMake variables CMAKE_CXX_COMPILER, etc. - but you need to pick the compiler on the first run; you can’t just reconfigure to get a new compiler.

## Setting compiler options 

## Using different compilers 

## {.standout}

Exercise. Configure a project to use a different compiler.

## Managing build types


## {.standout}

Exercise. Modify the CMake project to support multiple build types


## Libraries


## {.standout}

Move to the cluster


## CMake style 


Lunch Break
Episode 6: Advanced CMake Features
Generator expressions
Functions and Macros
Scripting in CMake
Exercise: Create a CMake macro for repetitive tasks.
Episode 7: Testing with CMake
Adding tests with CTest
Test-driven development with CMake
Exercise: Write and add several tests to the existing CMake project.
Episode 8: Installing and Packaging with CMake
Install commands
CPack for packaging
Exercise: Write CMake install rules and generate a package.
Episode 9: Managing Large Projects
Organizing a project with subdirectories
Interface libraries
Managing dependencies
Exercise: Refactor the project to use subdirectories.
Episode 10: Modern CMake Practices
Usage of modern CMake commands and targets
Avoiding common pitfalls
CMake project review and Q&A
Exercise: Participants review each other's CMake projects and provide feedback.
Conclusion and Wrap-Up
Recap of the workshop
Additional resources for further learning
Feedback and workshop evaluation


## Workflow

![CMake Project Files Generation Steps](./fig/CMakeProjectFilesGenerationSteps.png)