---
aspectratio: 169
---

# GENERATOR EXPRESSIONS  

## OVERVIEW 

CMake is a two step process:

- Configuration 
- Generation 

Show the output... 

Generally we have all the required data during the configuration stage...

...but every once in a while ...example


## EXAMPLE 

Consider once again the MPI hello world 
and use the generator expressions in that context with the code side by side

## SYNTAX OF A GENERATOR EXPRESSION 

```{.cmake style=cmakestyle}
$<EXPRESSION:arg1,arg2,arg3>
```

- If an expression requires an argument, add a colon `:`  and provide the `arg1, arg2, arg3` values, separated with a comma `,`

## NESTING 

DFJDKS

## CONDITIONAL EXPRESSIONS

```{.cmake style=cmakestyle}
$<IF:condition,true_string,false_string>
```

The second form is a shorthand for the preceding; it will only expand to a string if the condition is met:

```{.cmake style=cmakestyle}
$<condition:true_string >
```

As you can see, it breaks the convention of providing the EXPRESSION name as the first token. I assume that the intention here was to shorten the expression and skip those precious three characters, but the outcome can be really hard to rationalize

## TYPES OF EVALUATION 

- Generator expressions are evaluated to one of two types – Boolean or string. Boolean is represented by 1 (true) and 0 (false). Everything else is just a string.

- It's important to remember that nested expressions passed as conditions in conditional expressions are explicitly required to evaluate to Boolean.

## GENERATOR EXPRESSIONS 

Generator expression 

...

is evaluated during the generation stage, once the configuration is complete and the internal build system representation is created. This has a number of implications:

- You can not capture their output into a variable and print it to the console with the `message()`
 command

- To debug them (write it to a file where the overload GENERATE of the file command supports this)
- or add a custom target

## Example 

We will compile the following example source code (example.cpp):
#include <iostream>
#ifdef HAVE_MPI
#include <mpi.h>
#endif
int main() {
#ifdef HAVE_MPI
// initialize MPI
MPI_Init(NULL, NULL);
// query and print the rank
int rank;
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
std::cout << "hello from rank " << rank << std::endl;
// initialize MPI
MPI_Finalize();
#else
std::cout << "hello from a sequential binary" << std::endl;
#endif /* HAVE_MPI */
}
The code contains preprocessor statements (#ifdef HAVE_MPI ... #else ... #endif) so that
we can compile either a sequential or a parallel executable with the same source code.


## How to do it

When composing the CMakeLists.txt file, we will reuse some of the building blocks we
encountered in Chapter 3, Detecting External Libraries and Programs, Recipe 6, Detecting the
MPI parallel environment:
1. We declare a C++11 project:
cmake_minimum_required(VERSION 3.9 FATAL_ERROR)
project(recipe-09 LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_EXTENSIONS OFF)
set(CMAKE_CXX_STANDARD_REQUIRED ON)


2. Then, we introduce an option, USE_MPI, to select MPI parallelization and set it
ON by default. If it is ON, we use find_package to locate the MPI environment:
option(USE_MPI "Use MPI parallelization" ON)
if(USE_MPI)
find_package(MPI REQUIRED)
endif()
3. We then define the executable target and conditionally set the corresponding
library dependency (MPI::MPI_CXX) and preprocessor definition (HAVE_MPI),
which we will explain in a moment:
add_executable(example example.cpp)
target_link_libraries(example
PUBLIC
$<$<BOOL:${MPI_FOUND}>:MPI::MPI_CXX>
)
target_compile_definitions(example
PRIVATE
$<$<BOOL:${MPI_FOUND}>:HAVE_MPI>
)

4. If MPI is found, we also print the INTERFACE_LINK_LIBRARIES exported by
FindMPI.cmake to demonstrate the very handy cmake_print_properties()
function:
if(MPI_FOUND)
include(CMakePrintHelpers)
cmake_print_properties(
TARGETS MPI::MPI_CXX
PROPERTIES INTERFACE_LINK_LIBRARIES
)
endif()


5. Let us first configure the code with the default MPI paralellization switched ON.
Observe the output from cmake_print_properties():
$ mkdir -p build_mpi
$ cd build_mpi
$ cmake ..
-- ...
--
Properties for TARGET MPI::MPI_CXX:
MPI::MPI_CXX.INTERFACE_LINK_LIBRARIES = "-Wl,-rpath -
Wl,/usr/lib/openmpi -Wl,--enable-new-dtags -
pthread;/usr/lib/openmpi/libmpi_cxx.so;/usr/lib/openmpi/libmpi.so"
6. We compile and run the parallel example:
$ cmake --build .
$ mpirun -np 2 ./example
hello from rank 0
hello from rank 1
7. Now, let us step one directory up, create a new build directory, and this time
build the sequential version:
$ mkdir -p build_seq
$ cd build_seq
$ cmake -D USE_MPI=OFF ..
$ cmake --build .
$ ./example
hello from a sequential binary


## HOW IT WORKS

The build system for a project is generated by CMake in two phases: a configuration phase,
where CMakeLists.txt is parsed, and a generation phase, where the build environment is
actually generated. Generator expressions are evaluated in this second phase and can be
used to tweak the build system with information that can only be known at generation
time. Generator expressions are thus particularly useful when cross-compiling, where some
of the information is only available after the CMakeLists.txt has been parsed, or in multiconfiguration
projects, where the build system is generated at once for all the different
configurations the project can have, such as Debug and Release


In our case, we will use generator expressions to conditionally set a link dependency and
compile definition. For this, we can focus on these two expressions:
target_link_libraries(example
PUBLIC
$<$<BOOL:${MPI_FOUND}>:MPI::MPI_CXX>
)
target_compile_definitions(example
PRIVATE
$<$<BOOL:${MPI_FOUND}>:HAVE_MPI>
)
If MPI_FOUND is true, then $<BOOL:${MPI_FOUND}> will evaluate to 1. In this
case, $<$<BOOL:${MPI_FOUND}>:MPI::MPI_CXX> will evaluate to MPI::MPI_CXX and
the second generator expression will evaluate to HAVE_MPI. If we set USE_MPI to OFF,
MPI_FOUND is false and both generator expressions evaluate to empty strings, and thus no
link dependency is introduced and no preprocessor definition is set.
We could have achieved the same effect by introducing an if-statement:
if(MPI_FOUND)
target_link_libraries(example
PUBLIC
MPI::MPI_CXX
)
target_compile_definitions(example
PRIVATE
HAVE_MPI
)
endif()


This solution is a bit less compact but possibly a bit more readable. We can often re-express
if-statements using generator expressions and the choice is often a matter of taste.
However, generator expressions particularly shine when we need to access or manipulate
explicit file paths, since these can be difficult to construct using variables and if-clauses, and
in this case we clearly favor generator expressions for readability. This was the case in
Chapter 4, Creating and Running Tests, where we used generator expressions to resolve the
file path of a particular target. We will also appreciate generator expressions in Chapter 11,
Packaging Projects.

There is more
CMake offers three types of generator expression:
Logical expressions, with the basic pattern $<condition:outcome>. The basic
conditions are 0 for false and 1 for true, but any Boolean can be used as a
condition, provided that the correct keywords are used.
Informational expression, with the basic pattern $<information> or
$<information:input>. These expressions evaluate to some build system
information, for example, include directories, target properties, and so forth. The
input parameter to these expressions might be the name of a target, as in the
expression $<TARGET_PROPERTY:tgt,prop>, where the information obtained
will be the prop property on the tgt target.
Output expressions, with the basic pattern $<operation> or
$<operation:input>. These expressions generate an output, possibly based on
some input parameters. Their output can be used directly inside CMake
commands or combined with other generator expressions. For example, -
I$<JOIN:$<TARGET_PROPERTY:INCLUDE_DIRECTORIES>, -I> will generate a
string containing the include directories for the target being processed, each
prependend by -I.

## OVERVIEW 

CMake builds the solution in three stages – configuration, generation, and running the build tool. Generally, we have all the required data during the configuration stage. But every once in a while, we encounter the chicken and the egg problem. Take an example from the previous section – a target needs to know the path of a binary artifact of another target. But that information is only available after all the list files are parsed and the configuration stage is complete.

How do we deal with that kind of problem? We could create a placeholder for that information and postpone its evaluation to the next stage – the generation stage.

This is what generator expressions (sometimes called genexes) do. They are built around target properties such as LINK_LIBRARIES, INCLUDE_DIRECTORIES, COMPILE_DEFINITIONS, propagated properties, and many others, but not all. They follow rules similar to conditional statements and variable evaluation...