---
title: Introduction to Modern CMake
subtitle: Introduction to Build Systems (Generators) and Package Managers in HPC
author: 
  - Michael Redenti 
  - Mandana Safari
institute: 
  - m.redenti@cineca.it 
  - m.safari@cineca.it 
date: \today
aspectratio: 169
---

## IMPORTANT (IMPORTED LIBRARIES)

Just like executables, libraries may be defined as imported targets. These are heavily used 
by config files created during packaging or find module implementations. 

They do not define a library to be built by the project, rather they act as a reference to a library 
that is provided externally, eg. it already exists on the system, is built by some process outside 
the current CMake project, or is provided by the package that a config file is part of...

- Tip 
  ```{.cmake style=cmakestyle}
  cmake -B <build tree> -S <source tree>
  ```

We connect our libraries with executables by using the target_link_libraries() command. Without it, the compilation for executables would fail because of undefined symbols. Have you noticed that we invoked this command before actually declaring any of the libraries? When CMake configures the project, it collects the information about targets and their properties – their names, dependencies, source files, and other details.

After parsing all the files, CMake will attempt to build a dependency graph. And like with all valid dependency graphs, they're directional acyclic graphs. This means that there is a clear direction of which target depends on which, and such dependencies cannot form cycles.

## IMPORTANT (SIMPLIFYING THE TARGET NAMES)

Target is a name for something to do. Execute or build or create, depending on the target. Typically, target names represent an executable file or library file.

The term "target" comes from make command. make takes targets names as arguments and builds them using rules that specify what to do to create a specific target/file.

The build system generated by CMake "updates a target" (executes the commands needed to build the executable file or library file) when the prerequisite files have been modified since the target was last modified or the target does not exist ("the target" = the file that is the result of building the target).

A target represents either an executable (functions and data in a binary that has a main-function/entrypoint (a program)), or a library (functions and data in a binary with no main-function/entrypoint) in a buildsystem. For more information, see the docs on binary targets, and the docs for add_executable and for add_library.

Targets can be part of a project (in which case they have source files and need to be built as part of the buildsystem), or IMPORTED, in which case they already exist in binary form and have no sources and do not need to be built (they were already built outside the buildsystem to be generated for a project).

Targets can have dependencies between them. Ex. An executable target depending on a library target to use its functions and data. For more info, see the docs for target_dependencies, which can have implications for linking binaries together, and for build order: making sure dependent targets are re-built (if needed- which is not always the case, Ex. with non-interface changes to shared libraries) when depended-upon targets need to be rebuilt.

There are some target types which are not IMPORTED which also have nothing to build (Ex. interface libraries, and other types you can read about in the add_library docs, but those are more "advanced" features).

## OTHER 

The module will produce a text file that we can import to the Graphviz visualization software, which can render an image or produce a PDF or SVG file that can be stored as part of the software documentation. Everybody loves great documentation, but hardly anyone likes to create it – now, you don't need to!

If you're in a rush, you can even run Graphviz straight from your browser at this address:

https://dreampuf.github.io/GraphvizOnline/

## EXTREMELY IMPORTANT TO ADD 

To reiterate, a library is a collection of files without an entry point whereas an executable is a program with an entry point defined in the main function.

## WHY EFFICIENT BUILD SYSTEMS MATTER

<!-- 
  Modern build systems should be able to build the software, package it, test it
 
  The choice for a particular build system should be guided by 
  the following idea: 
    every moment a developer spends writing or debugging build definitions is a second wasted. So is every second spent waiting for the build system to actually start compiling code.

    Disadvantages of GNU Make and Autotools vs. CMake
    GNU Make
      Complexity in Large Projects: GNU Make can become unwieldy for large and complex projects due to its simple syntax and limited built-in functionalities.
      
      Platform Dependence: Makefiles often require significant modification to work across different platforms, making cross-platform development more cumbersome.
      
      Manual Dependency Management: Developers must manually handle dependencies, which can lead to errors and maintenance challenges.
      
      Limited Built-in Functionality: Lacks advanced features like testing, packaging, and configuration, requiring additional tools or scripts.
      
      Readability and Maintainability: Makefiles can become hard to read and maintain, especially with complex conditional logic and variable use.

  Autotools
    Steep Learning Curve: Autotools has a steep learning curve due to the complexity and number of tools involved (autoconf, automake, libtool).
    
    Verbose and Redundant Scripts: Generates a large number of files and scripts, which can be overwhelming and difficult to manage.
    
    Slow Configuration Process: The configure script generated by Autotools can be slow, affecting the overall build time.
    
    Limited Windows Support: Although possible, using Autotools on Windows is less straightforward compared to Unix-like systems, often requiring additional tools like Cygwin or MSYS.
    
    Maintenance Overhead: Keeping the Autotools scripts up to date and working correctly can require significant maintenance effort.
-->

\centering 

**OBJECTIVE** Spend time on software development, not on software building!

## TRADITIONAL BUILD SYSTEMS - CHALLENGES


GNU Make
  : Complications with large projects 
  <!-- 
    Development and maintenance of Makefiles can become very complicated as the project grows (error prone to deal with thousands of files and dependencies) 

    Structuring Makefiles for a huge project is possible but very time consuming

    Often see developing and maintaining multiple Makefiles targeting a specific platform or even compiler toolchain
  -->
  : Platform dependence 
  <!-- 
    Make does not know which compiler (options) we want and which environment we are on.

    OS specific commands (ls, grep, dir, ..., slash, backslash) will not port.
    
    Surely one can hack their ways to achieve portabilty but GNU Make alternatives: NMake (Visual Studio) where shell commands are obviously targeted at Windows -->
  : Manual Dependency Management
  <!-- 
    Developers must manually handle dependencies, which can lead to errors and maintenance challenges. 
    If the project grows, maintaining these dependencies manually becomes error-prone and cumbersome.

    In CMake, dependency management is handled automatically.
  -->

<!--
  All of the above approached poorly integrate with IDEs and 
  cross-platform or IDE integrations would require manual updates across different build tools and IDEs respective configuration files
-->

<!--
  CMake is particularly favored for its cross-platform capabilities and ease of managing complex projects. GNU Make remains a staple in Unix-like environments for its simplicity and power. 
-->

. . . 

\hspace{0.5cm}

<!-- 
    I am not sure this is true : Limited to Unix platforms : Generates only Makefiles
-->

Autotools <!-- a.k.a. Autohell -->

  : Complex manual scripts (Bourne shell, m4) 
  <!-- Long, difficult to understand scripts -->

  : Poor IDE integration

  : Maintenance Overhead
  
  <!-- 
    Keeping the Autotools scripts up to date and working correctly can require significant maintenance effort.

    Manual ordering of Fortran module files 
  -->
  
  <!-- 
    You need to make sure that the module files are created before they are referenced 
  --> 


## BUILD SYSTEMS POPULARITY

\begin{center}
    \includegraphics[width=1.2\paperwidth,height=0.8\paperheight]{./fig/GoogleTrends.png}
\end{center}


# INTRODUCTION TO CMAKE

## WHAT IS CMAKE?

\begin{tikzpicture}[remember picture,overlay]
\node[anchor=north east,inner sep=0pt, xshift=.3cm, yshift=-0.8cm] at (current page.north east) {
  \href{http://www.example.com}{\includegraphics[width=4cm]{./fig/Logo_Kitware.png}}
};
\end{tikzpicture}

<!-- 
 ... that provides a family of software development tools

 - Build System Generator => it generates files, it does not build
 
- Dependency discovery is awesome (find_package())
- Can not overcome the limitations of the underlying IDEs
-->

- **C**ross Platform **Make** is an open-source **build system generator**.

- It allows us to: 
  - structure and build C/C++/Fortran/... projects $\Rightarrow$ **CMake**
  - easily integrate third-party dependencies
  - orchestrate tests $\Rightarrow$ **CTest, CDash**
  - package projects $\Rightarrow$ **CPack**

- Supports generating build-systems for multiple languages
  - C/C++, Fortran, CUDA, HIP, C#, ...

- Version 3.0 was released in June 2014 and signals the beginning of "Modern CMake".
<!-- 
  Let developers use the IDE and tools they are most familiar with, they are not going to be as productive if you force them to use the command line

  Nonostante the rich C++ ecosystem that is out there with various vendors creating IDEs, compilers, architecture but you can still express your build in one tool
-->


<!-- 
  CMake generates native makefiles and workspaces that can be used in the compiler environment of your choice

  Enable building (CMake), testing (CTest, CDash) and packaging (CPack) of software
-->

## CMAKE'S POSITION AMONG BUILD SYSTEMS

standalone
  : Make, NMake, SCons, Ninja

integrated
  : Visual Studio, Xcode, Eclipse

generators
  : Autotools (a.k.a. Autohell), **CMake**, Meson, Bazel


## BUILD SYSTEM GENERATOR

<!--
  CMake is a tool designed to help you build and test your software. It is now more popular than ever and is now supported by some major IDEs and libraries, including Android Studio, CLion, QtCreator or Visual Studio.

  Let's cover the basics, understand how CMake works and how to write modern and extensible cross-platform build scripts with CMake.

  CMake as a Scripting Language
  CMake is a tool designed to manage the build process of software projects. It uses a scripting language to define the build process in CMakeLists.txt files. Here’s how it fits the characteristics of a scripting language:

  Interpreted Execution: CMake processes the CMakeLists.txt files line by line to generate build instructions (e.g., Makefiles or Visual Studio project files).
-->

CMake uses **a scripting language to define the build process** in **CMakeLists.txt** files, which are processed to generate project files for major IDEs and build tools.

:::::::::::::: {.columns}
::: {.column width="5%"}

::: 
::: {.column width="85%"}

```plantuml
left to right direction
skinparam PackagePadding 2
skinparam BoxPadding 2
skinparam NodePadding 2
skinparam style strictuml
skinparam padding 0
scale 0.8

skinparam rectangle {
  BackgroundColor<<Windows>> LightBlue
  BackgroundColor<<macOS>> LightBlue
  BackgroundColor<<Linux>> LightBlue
  BackgroundColor<<Tool>> Pink
}

skinparam Arrow {
  Color Black
}

file "CMakeLists.txt" as ST
rectangle "CMake" as CM #Pink

collections "Visual Studio" as VS <<Windows>> #LightBlue
file "XCode" as XC <<macOS>> #LightBlue
file "Make" as MK <<Linux>> #LightBlue

rectangle "Make" as make #Pink
rectangle "xcode" as xcode #Pink
rectangle "visual-studio" as visual #Pink

ST --> CM

CM --> VS
CM --> XC
CM --> MK

MK <-- make 
XC <-- xcode
VS <-- visual
```

::: 
::: {.column width="10%"}

:::
:::::::::::::: 


## CMAKE FEATURES 

<!-- 

## WHY SHOULD YOU USE CMAKE 

- You want to avoid hard-coding paths

- You need to build a package on more than one computer
- You want to use CI (continuous integration)
- You need to support different OSs (maybe even just flavors of Unix)
- You want to support multiple compilers
- You want to use an IDE, but maybe not all of the time
- You want to describe how your program is structured logically, not flags and commands
- You want to use a library
- You want to use tools, like Clang-Tidy, to help you code
- You want to use a debugger

-->

\vspace{.3cm}

:::::::::::::: {.columns}
::: {.column width="50%"}

**Cross-platform** (Linux, Windows, macOS, ...)

\vspace{0.2cm}

**Open Source**

\vspace{0.2cm}

**Multiple Generators**

- Makefiles (Unix, NMake, Borland, ...)
- Ninja
- Microsoft Visual Studio (.sln)
- Eclipse
- Xcode

\vspace{0.2cm}


**Direct CMake integration with IDEs** 

  - Microsoft Visual Studio 2017...20??
  - JetBrains CLion


:::

. . . 

::: {.column width="50%"}

<!--

  High-Level Abstractions: CMake provides commands and functions that abstract complex build tasks. For example, add_executable is a high-level command that simplifies the process of defining an executable target.

  Ease of Use: Writing CMake scripts is generally straightforward, focusing on specifying what to build and how, without delving into the details of the build system being generated.

  Importance of Order in CMakeLists.txt
  In scripting languages, the order of commands can be crucial because the interpreter executes them sequentially. This is also true for CMake:

  Sequential Execution: Commands in CMakeLists.txt are executed in the order they appear. This means that each command can depend on the results of the commands that preceded it.
  Dependencies and Definitions: If a command relies on a variable or target defined by a previous command, changing the order could result in errors or unexpected behavior.
  Scope and Visibility: The scope of variables and targets can be influenced by their position in the script. For example, a variable defined within a function or block may not be accessible outside of it.


  perhaps add support with google test and dynamic analysis - general support for test frameworks, static and dynamic analysis of your code
-->


**Dependency discovery made easy**

- `find_package()`

\vspace{0.2cm}

**Automatic chaining of library dependency information**

\vspace{0.2cm}


**Compiler language level support**

- C, C++, Fortran, CUDA, HIP, ...

\vspace{0.2cm}

**Fortran Module Order**  

\vspace{0.2cm}

**Test frameworks integration**

- Dash, GoogleTest

\vspace{0.2cm}

**CMake scripting language**
<!-- 

  CMake as a Scripting Language
  CMake is a tool designed to manage the build process of software projects. It uses a scripting language to define the build process in CMakeLists.txt files. Here’s how it fits the characteristics of a scripting language:

  Interpreted Execution: CMake processes the CMakeLists.txt files line by line to generate build instructions (e.g., Makefiles or Visual Studio project files).
  
  Automatic ordering of Fortran files based on `use` statements in the code for a library

  CMake is an open-source project that serves as a tool for building, testing, packaging, and distributing cross-platform software
    CMake is a scripting language written in C++
    CMake is a de facto industry standard for building C++ projects
    CMake is divided into 3 command-line tools:
    cmake: for generating compiler-independent build instruction
    ctest: for detecting and running tests
    cpack: for packing the software project into convenient installers

    Compiler indipendent configuration files (need example)

Uses CMake language

- Automatic dependency generation 
- 
- **Single description file** generate builds for many build systems and platforms from one description file 
  
- **Integration** easy to build end-to-end build systems using CTest and CPack
- It's platform- and - compiler-agnostic, allowing reuse of CMake scripts across different platforms.
- facilitate generation of files for different build systems across various platforms and IDEs
- automatically track and propagate internal dependencies
- Graphviz output for visualizing dependency trees
- Full cross platform install() system
- Compute link depend information, and chaining of dependent libraries

Discussion on how CMake fits into the software development process, its role in streamlining development, testing, deployment, and complex use cases like large-scale projects and cross-platform development.

-->

:::
::::::::::::::
  

## CMAKE LANGUAGE OVERVIEW (I)

\vspace{.5cm}

:::::::::::::: {.columns}
::: {.column width="50%"}

**Command based, one per line** 

```{.cmake style=cmakestyle}
set(FOO "bar")
add_executable(foo bar.cpp)
if(FOO)
```

\vspace{.2cm}

**Commands do not return values, no nesting**

\vspace{.2cm}

**Commands may have arguments and overloads** 

```{.cmake style=cmakestyle}
file(WRITE <file> <content>)
file(READ <file> <variable>)
```

\vspace{.2cm}

**link to documentation**

. . . 

:::
::: {.column width="50%"}

**Variables are set with command `set()`**

\vspace{.2cm}

**Variables are all strings**

```{.cmake style=cmakestyle}
set(FOO "a")
set(FOO a)
set(FOO 42)
```

\vspace{.2cm}

**Lists are semicolon-separated strings**

```{.cmake style=cmakestyle}
set(FOO "a;b;c")
set(FOO a b c)
```


\vspace{.2cm}

**Variables are read using `${}`**

```{.cmake style=cmakestyle}
list(APPEND FOO "d") # FOO="a;b;c;d"
```

:::
::::::::::::::


## CMAKE LANGUAGE OVERVIEW (II)

\vspace{.2cm}

:::::::::::::: {.columns}
::: {.column width="50%"}

**Control flow**

```{.cmake style=cmakestyle}
if() / elseif() / else() / endif()
```

```{.cmake style=cmakestyle}
foreach() / endforeach()
```

```{.cmake style=cmakestyle}
while() / endwhile()
```

```{.cmake style=cmakestyle}
break() / continue()
```

\vspace{.2cm}

**Comments start with #**

```{.cmake style=cmakestyle}
# I am a single line comment
```

:::
::: {.column width="50%"}

**Read another CMake file in the same context**

```{.cmake style=cmakestyle}
include(<file>)
```

\vspace{.2cm}


**Read another `CMakeLists.txt` file in `<dir>` in a new context**

```{.cmake style=cmakestyle}
add_subdirectory(<dir>)
```

\vspace{.2cm}

**Print a message**
<!-- 
  Usefule for displaying status, progress, warning or errors 
-->

```{.cmake style=cmakestyle}
message(<text>)
```

:::
::::::::::::::

## CMAKE LANGUAGE OVERVIEW (III)

<!--
  Looking back on the material covered in this book so far, CMake’s syntax is already starting to look
  a lot like a programming language in its own right. It supports variables, if-then-else logic, looping
  and inclusion of other files to be processed. It should be no surprise to learn that CMake also
  supports the common programming concepts of functions and macros too. Much like their role in
  other programming languages, functions and macros are the primary mechanism for projects and
  developers to extend CMake’s functionality and to encapsulate repetitive tasks in a natural way.
  They allow the developer to define reusable blocks of CMake code which can be called just like
  regular built-in CMake commands. They are also a cornerstone of CMake’s own module system
-->

\vspace{.5cm}

:::::::::::::: {.columns}
::: {.column width="50%"}

**FUNCTIONS**


**Defined using the `function()` command**

```{.cmake style=cmakestyle}
function(name [arg1 [arg2 [...]]])
# Function body (i.e. commands) ...
endfunction()
```

\vspace{.2cm}

**Example**

```{.cmake style=cmakestyle}
function(func_name arg1 arg2)
  message("Argument 1: ${arg1}")
  message("Argument 2: ${arg2}")
endfunction()

func_name("value1" "value2")
```

:::
::: {.column width="50%"}

. . . 

**MACROS**

**Defined using the `macro()` command**

```{.cmake style=cmakestyle}
macro(name [arg1 [arg2 [...]]])
# Macro body (i.e. commands) ...
endmacro()
```

\vspace{.2cm}

**Example** - please show the scope difference in the example

```{.cmake style=cmakestyle}
macro(macro_name arg1 arg2)
  message("Argument 1: ${arg1}")
  message("Argument 2: ${arg2}")
endmacro()

macro_name("value1" "value2")
```

:::
::::::::::::::

## CMAKE LANGUAGE OVERVIEW (IV)

\centering The CMake language is very rich in features and capabilities!

\vspace{0.3cm}

**COMMANDS**

Numerous commands to handle various build system tasks
  
```{.bash style=bashstyle}
$ cmake --help-command-list | wc -l
```

A multitude of variables control the build process

## CMAKE MODULES OVERVIEW

- A set of predefined scripts (Modules)  <!-- CMake modules extend the functionality of the language by providing -->

- CMake modules extend the functionality of the language by providing predefined scripts that simplify complex tasks.

CMake modules extend the functionality of the language by providing predefined scripts that simplify complex tasks.

- Example: `FindPackage` modules help in locating and configuring dependencies.

- Provide a list of modules organised by objective

<!-- 

  ## The complexity of the build process (compiled languages (C/C++/Fortran))
  
  Compilers, linkers, testing frameworks, packaging systems, and more contribute to the complexity of deploying high-quality, robust software. 

  Computers cannot execute such a source file, they must be translated into binary processor instructions first. Thus, next step is to feed this program to a compiler, which does this translation for us. There is a multitude of ways of doing that, depending on the compiler. The compiler then takes the source file and “compiles” it into an executable program which you can then start.

  More complex programs will usually consist of multiple C++ files which are then separately compiled into intermediate output files (usually with a .o or .obj extension) and then “linked” together by a program called linker to an executable. In fact, even if just a single source file is compiled into an executable, the compiler automatically invokes the linker behind the scenes.

![](./fig/BuildProcess.png)  

-->

# Workshop Outline and Setup

## Agenda 

| MORNING                               | AFTERNOON                  |
| ------------------------------------- | -------------------------- |
| **Introduction**                      | **Finding dependencies**   |
| - Overview of the CMake Language      | - Modules                  |
| **Basic Steps with CMake**            | - Config                   |
|                                       |                            |
| **Variables**                         | **Testing**                |
| - Local, Cache, Environment variables |                            |
| - Compilation                         |                            |
| **Targets**                           | **Generator expressions**  |
| - Targets have properties             | **Conclusion and wrap up** |
| - Visibility Levels  and Inheritance  |                            |
| **Hands on**                          | **Hands on**               |



<!-- 
  Details on required software installations, system configurations, how to access materials, and initial setup instructions.

-->

## Setup

Logging into G100 Cineca cluster

```{.bash style=bashstyle}
$ ssh <username>@login.g100.cineca.it
```

Clone the exercises repository

```{.bash style=bashstyle}
$ git clone ...
```

Loading the cmake module

```{.bash style=bashstyle}
$ module load cmake/3.21.4
```


<!--
  The add_subdirectory command allows a project to be separated into directories

  CMake is a declarative language which contains 90+ commands. It contains general purpose constructs: set , unset, if , elseif , else , endif, foreach, while, break
-->