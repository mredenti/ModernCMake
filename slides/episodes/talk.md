## CCMake

The ccmake executable is the CMake curses interface. Project configuration settings may be specified interactively through this GUI. Brief instructions are provided at the bottom of the terminal when the program is running.

-S <path-to-source>
Path to root directory of the CMake project to build.

-B <path-to-build>
Path to directory which CMake will use as the root of build directory.

If the directory doesn't already exist CMake will make it.


## IMPORTANT (SIMPLIFYING THE TARGET NAMES)
CMake is one of the most popular makefile generator systems for C++. If you look at an open-source library on GitHub, chances are it is either instrumented by CMake or at least has a CMake integration


Target is a name for something to do. Execute or build or create, depending on the target. Typically, target names represent an executable file or library file.

The term "target" comes from make command. make takes targets names as arguments and builds them using rules that specify what to do to create a specific target/file.

The build system generated by CMake "updates a target" (executes the commands needed to build the executable file or library file) when the prerequisite files have been modified since the target was last modified or the target does not exist ("the target" = the file that is the result of building the target).

A target represents either an executable (functions and data in a binary that has a main-function/entrypoint (a program)), or a library (functions and data in a binary with no main-function/entrypoint) in a buildsystem. For more information, see the docs on binary targets, and the docs for add_executable and for add_library.

Targets can be part of a project (in which case they have source files and need to be built as part of the buildsystem), or IMPORTED, in which case they already exist in binary form and have no sources and do not need to be built (they were already built outside the buildsystem to be generated for a project).

Targets can have dependencies between them. Ex. An executable target depending on a library target to use its functions and data. For more info, see the docs for target_dependencies, which can have implications for linking binaries together, and for build order: making sure dependent targets are re-built (if needed- which is not always the case, Ex. with non-interface changes to shared libraries) when depended-upon targets need to be rebuilt.

There are some target types which are not IMPORTED which also have nothing to build (Ex. interface libraries, and other types you can read about in the add_library docs, but those are more "advanced" features).

## EXTREMELY IMPORTANT TO ADD 

- To reiterate, a library is a collection of files without an entry point whereas an executable is a program with an entry point defined in the main function.

- build requirements can be propagated from the dependency to the user to the one depending on it; the propagation of build requirements to make them become build requirements of our new target is automatic

- In traditional CMake there usage requirements need to be propagated manually 

- In modern CMake, build requirements are set on targets themselves, sometimes you do not even have to set them yourself because they come automatically from this target in the form of usage requirements 

- In traditional CMake, keeping track of usage requirements was done through cache variables. 

- In traditional CMake, build requirements are done on the environment meaning they have directory scope. The build requirement is set for all targets defined there and for all targets defined in subdirectories


- Ok, I think we should probably get started. 
- My name is Michael and I work as a ... here in CINECA. I mainly deal with ...
- Today I will talk about CMake. The motivation for talking about CMake in this workshop definitely has to do with its wide adoption...
  - Just like C++, CMake has a big userbase, it dominates the industry 
  - They have a strong focus on backwards compatibility
  - complex, feature, rich, "multi paradigm toolset" (just like C++)
  - bad reputation, horrible syntax, "bloated"


## WHAT IS CMAKE 

- CMake is a portable build system generator, but not a build system. 

- The main thing about being modern is the Target Centric approach. All the targets that you declare full carry their own build and usage requirements with it and they will propagate this.


## WHY EFFICIENT BUILD SYSTEMS MATTER 


- Today we are going to talk about CMake
- Good tools matter when it comes to building software
- The thing about CMake is very flexible, you can do a lot of things in order to boost productivity


## POPULARITY 

- Given its popularity ...


## WHAT IS CMAKE 

- CMake is a BUILD FILE generator, meaning it generates files; it does not build. CMake allows you to generate the build files for your most favourite build system you want to use.

- The CMake language is platform and compiler indipendent language

- Not the nicest language, too many features, ...

- The CMake ecocsystem is a family of tools for building, testing and packaging your software

- CMake puts a lot of effort on backwards compatibility, so that old CMake scripts should work

The CMake project started sometime around year 2000. 


## CMAKE FEATURES 

- CMake itself is a cross--platform software, meaning that it will run on a lot different platforms: OS, Windows, Linux

- Multiple Generators: As we already mentioned CMake is a build file generator and so it will build files for many IDEs and build tools

- Direct CMake integration: given its popularity it is now directly supported and bundled with major IDEs; you can build CMake projects directly from the IDE..


- Language is quite flexible and also works in scripting mode as if it was bash; but if you were on windows you do not want to write in power shell or whatever



## CMAKE LANGUAGE 

- The CMake language is **command based**, one command per line
  
- All of these commands are procedures, they do not return values. And so you can not nest them


- Command may have many arguments and overloads. For instance, the command `file()` has multiple profiles, one allows to write data to file, another will read data from file. 

- The CMake documentation will show you all the different variants, examples with the different parameters that you can pass

## BASIC STEPS WITH CMAKE 

- Detection of the compiler, build flags, configuration


# Introduction to CMake

## MOTIVATION 

- **productivity** spend time on software development, not software building 

## WHAT IS CMAKE

- CMake is a build file generator which means that it generates files but it does not actually build

- In CMake you write scripts called CMakeLists.txt which describe the build in a compiler and platform independent language

- Uses CMake language which is quite flexible as it allows scripting ...

- CMake allows you to build, test and package your software

## CMake Features 

- CMake is very popular such that it has been widely adopted across all major IDEs. This integration allows to open a CMake project, debug and so on directly through the IDE (interface)

- Perhaps it is not integrates with XCode but it can generate XCode files



## TARGET CONFIGURATION

- For your targets you  need to define include directories, to sepcify where are the headers, 
- You need to specify compile definitions, preprocessor macros, definitios 
- compile options (for example if i want to define all of the warnings)
- All of these commands have visibility levels




## CMake language 

- CMake language is command based, one command per line

- CMake commands are procedures, they do not return values, they are not functions --> you can not nest them

- Commands can have many arguments and overloads 
  For instance, the file command has multiple profiles. 
  One allows to WRITE data to a file, another allows to READ data from a file

- Go to the documentation

  
- VARIABLES are strings -> it is up to the commands to interpret all of the values in they want but most of the time they are going to be strings 

- even lists are semi-colon separated strings












## Commands vs Functions

- In CMake, both commands and functions are used to perform specific tasks during the build configuration process, but they differ in scope, definition and usage. 

- Definition and Scope:
  - Commands in CMake are built-in operations provided by the CMake language. They are always available and can be used in any CMakeLists.txt file 

  - Commands have global scope, meaning their effects are not limited to the file or block in which they are used 

  - Functions in CMake are defined using the `function()` command and are called by their name
  - Functions can take arguments and optionally "return" values by modifying passed variables
  - Functions are user-defined and make use of commands to perform conditional logic, execute processes and so on...




## IMPORTANT (IMPORTED LIBRARIES)

Just like executables, libraries may be defined as imported targets. These are heavily used 
by config files created during packaging or find module implementations. 

They do not define a library to be built by the project, rather they act as a reference to a library 
that is provided externally, eg. it already exists on the system, is built by some process outside 
the current CMake project, or is provided by the package that a config file is part of...

- Tip 
  ```{.cmake style=cmakestyle}
  cmake -B <build tree> -S <source tree>
  ```

We connect our libraries with executables by using the target_link_libraries() command. Without it, the compilation for executables would fail because of undefined symbols. Have you noticed that we invoked this command before actually declaring any of the libraries? When CMake configures the project, it collects the information about targets and their properties â€“ their names, dependencies, source files, and other details.

After parsing all the files, CMake will attempt to build a dependency graph. And like with all valid dependency graphs, they're directional acyclic graphs. This means that there is a clear direction of which target depends on which, and such dependencies cannot form cycles.



<!-- 
  Modern build systems should be able to build the software, package it, test it
 
  The choice for a particular build system should be guided by 
  the following idea: 
    every moment a developer spends writing or debugging build definitions is a second wasted. So is every second spent waiting for the build system to actually start compiling code.

    Disadvantages of GNU Make and Autotools vs. CMake
    GNU Make
      Complexity in Large Projects: GNU Make can become unwieldy for large and complex projects due to its simple syntax and limited built-in functionalities.
      
      Platform Dependence: Makefiles often require significant modification to work across different platforms, making cross-platform development more cumbersome.
      
      Manual Dependency Management: Developers must manually handle dependencies, which can lead to errors and maintenance challenges.
      
      Limited Built-in Functionality: Lacks advanced features like testing, packaging, and configuration, requiring additional tools or scripts.
      
      Readability and Maintainability: Makefiles can become hard to read and maintain, especially with complex conditional logic and variable use.

  Autotools
    Steep Learning Curve: Autotools has a steep learning curve due to the complexity and number of tools involved (autoconf, automake, libtool).
    
    Verbose and Redundant Scripts: Generates a large number of files and scripts, which can be overwhelming and difficult to manage.
    
    Slow Configuration Process: The configure script generated by Autotools can be slow, affecting the overall build time.
    
    Limited Windows Support: Although possible, using Autotools on Windows is less straightforward compared to Unix-like systems, often requiring additional tools like Cygwin or MSYS.
    
    Maintenance Overhead: Keeping the Autotools scripts up to date and working correctly can require significant maintenance effort.
-->


<!-- 

## PKGCONFIG 

\vspace{.3cm}

- If neither a `Find<PackageName>.cmake` module nor a `<PackageName>Config.cmake` is available, CMake can also use `pkg-config` to find and configure packages. put link

\vspace{.3cm}

**Example. Using `pkg-config` with FFTW**

:::::::::::::: {.columns}
::: {.column width="50%"}

```{.bash style=bashstyle}
$ ls <>/fftw-/lib/pkgconfig
fftw3f.pc  fftw3.pc
```

:::
::: {.column width="50%"}

```{.bash style=bashstyle}
$ cat <>/fftw3.pc
prefix=<path-to-root-fftw>
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir=${prefix}/include

Version: 3.3.10
Libs: -L${libdir} -lfftw3 
Libs.private: -lm
Cflags: -I${includedir}
```
:::
::::::::::::::


## WRITE YOUR OWN DETECTION SCRIPT

- CMake provides extensive modules for finding many popular software packages. Before writing your own detection scripts, always check the CMake online documentation for existing `Find<PackageName>.cmake` modules.


  to enable the discovery of files, programs, libraries...


- At times writing your own detection scripts might be the only option. CMake provides a family of `find_*()` commands for this purpose:
  
  **find_path()** 
    : to find a directory containing the named file

  **find_file()**
    : to find a full path to a named file

  **find_library()**
    : to find a library

  **find_program()** 
    : to find a program


  IMPORTANT AND INTERESTING

  For a large selection of common dependencies, the Find<PackageName>.cmake modules shipped with CMake work flawlessly and are maintained by the CMake developers. This lifts the burden of programming your own dependency detection tricks.

  find_package will set up imported targets: targets defined outside your project that you can use with your own targets. The properties on imported targets defines usage requirements for the dependencies. A command such as:

  target_link_libraries(your-target
    PUBLIC
      imported-target
    )
  will set compiler flags, definitions, include directories, and link libraries from imported-target to your-target and to all other targets in your project that will use your-target.

  These two points simplify enormously the burden of dependency detection and consistent usage within a multi-folder project.

## WRITING A FindFFTW3.cmake (I)

:::::::::::::: {.columns}
::: {.column width="85%"}

1. Check for FFTW environment variables and set them if not already defined.

```{.cmake style=cmakestyle}
if(NOT FFTW_HOME AND DEFINED ENV{FFTW_HOME} )
    set(FFTW_ROOT $ENV{FFTW_HOME} )
endif()

if(NOT FFTW_ROOT AND DEFINED ENV{FFTW_ROOT} )
    set(FFTW_ROOT $ENV{FFTW_ROOT} )
endif()
```

2. Use `find_path()` to locate the directory containing the `fftw3.h` header file.
   
```{.cmake style=cmakestyle}
find_path( 
    FFTW_INCLUDE_DIR 
    NAMES fftw3.h
    PATHS 
        ${FFTW_ROOT}/include
        /usr/local/include
        /usr/include
    DOC "Path to FFTW include directory")
```

:::
::: {.column width="15%"}

\vspace{2.5cm}

\begin{adjustbox}{margin=-1cm 0cm 0cm 0cm}
\begin{forest}
  pic dir tree,
  where level=0{}{
    directory,
  },
  [ 
    [\colorbox{pink}{FindFFTW3.cmake}, file
    ]
  ]
\end{forest}
\end{adjustbox}

:::
::::::::::::::


## WRITING A FindFFTW3.cmake (II)

\vspace{0.2cm}

:::::::::::::: {.columns}
::: {.column width="85%"}

3. Locate the FFTW library file.

```{.cmake style=cmakestyle}
find_library( 
    FFTW_LIBRARY 
    NAMES fftw3
    PATHS ${FFTW_ROOT}
    PATH_SUFFIXES "lib" "lib64" 
    DOC "Path to FFTW library")
```

4. Include the `FindPackageHandleStandardArgs` module and use `find_package_handle_standard_args()` to validate the found paths.
   
```{.cmake style=cmakestyle}
include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(
  FFTW
  FOUND_VAR 
    FFTW_FOUND
  REQUIRED_VARS 
    FFTW_LIBRARY FFTW_INCLUDE_DIR)
```

:::
::: {.column width="15%"}

\vspace{2.5cm}


\begin{adjustbox}{margin=-1cm 0cm 0cm 0cm}
\begin{forest}
  pic dir tree,
  where level=0{}{
    directory,
  },
  [ 
    [\colorbox{pink}{FindFFTW3.cmake}, file
    ]
  ]
\end{forest}
\end{adjustbox}

:::
::::::::::::::

## WRITING A FindFFTW3.cmake (III)

\vspace{0.2cm}

:::::::::::::: {.columns}
::: {.column width="85%"}

4. Set the `FFTW_LIBRARIES` and `FFTW_INCLUDE_DIRS` if FFTW is found.

```{.cmake style=cmakestyle}
if(FFTW_FOUND)
  set(FFTW_LIBRARIES ${FFTW_LIBRARY})
  set(FFTW_INCLUDE_DIRS ${FFTW_INCLUDE_DIR})
endif()
```

5. Create an imported target for FFTW using `add_library()` and set the appropriate properties.
   
```{.cmake style=cmakestyle}
if(FFTW_FOUND AND NOT TARGET FFTW3::fftw3)
  add_library(FFTW3::fftw3 UNKNOWN IMPORTED)
  set_target_properties(FFTW3::fftw3 PROPERTIES
    IMPORTED_LOCATION "${FFTW_LIBRARY}"
    INTERFACE_INCLUDE_DIRECTORIES "${FFTW_INCLUDE_DIR}")
endif()

set_target_properties(FFTW3::fftw3 PROPERTIES
  INTERFACE_LINK_LIBRARIES "m")
```

:::
::: {.column width="15%"}

\vspace{2.5cm}


\begin{adjustbox}{margin=-1cm 0cm 0cm 0cm}
\begin{forest}
  pic dir tree,
  where level=0{}{
    directory,
  },
  [ 
    [\colorbox{pink}{FindFFTW3.cmake}, file
    ]
  ]
\end{forest}
\end{adjustbox}

:::
::::::::::::::

## RECAP 

\vspace{.3cm}

In CMake, packages are defined and found in two primary ways:

**Module Packages**: Defined by CMake or individual projects, typically providing variables, macros, functions, and imported targets. Example: FindMPI.cmake.

**Config Packages**: Provided by the package itself, usually defining imported targets. Example: <Package>Config.cmake.

\vspace{.2cm}

Modules: Defined by CMake or projects, harder to keep up to date as packages evolve.

Config: Provided by the package itself, closely aligned with CMake's find commands, ensuring compatibility and ease of use.
Projects should prefer imported targets due to their robustness and better integration with CMakeâ€™s transitive dependency features.


## INTEGRATION WITH TEST FRAMEWORKS

we do not discuss here ...


## USING TIMEOUTS FOR LONG TESTS

- Ideally tests should take only a short time in order to motivate the developers to run the test often, and to encourage testing every commit. 

- At times, tests might take longer or get stuck (eg. high file I/O load) and we may need to implement timeouts to termitate tests that go overtime before they pile up and delay the entire terst and deploy pipeline.

- Implementing timeouts can be achieved with properties too...


[CMake Properties On Tests - Documentation](https://cmake.org/cmake/help/v3.19/manual/cmake-properties.7.html#properties-on-tests)

## VALGRIND EXAMPLE SOMEWHERE

lkl


## Using timeouts for long tests

The code for this recipe is available at https:/ / github. com/ dev- cafe/
cmake- cookbook/ tree/ v1. 0/ chapter- 04/ recipe- 07. The recipe is valid
with CMake version 3.5 (and higher), and has been tested on GNU/Linux,
macOS, and Windows.
Ideally, the test set should take only a short time, in order to motivate developers to run the
test set often, and to make it possible (or easier) to test every commit (changeset). However,
some tests might take longer or get stuck (for instance, due to a high file I/O load), and we
may need to implement timeouts to terminate tests that go overtime, before they pile up
and delay the entire test and deploy pipeline. In this recipe, we will demonstrate one way
of implementing timeouts, which can be adjusted separately for each test.

In addition, we specify a TIMEOUT for the test, and set it to 10 seconds:
set_tests_properties(example PROPERTIES TIMEOUT 10)

Now, to verify that the TIMEOUT works, we increase the sleep command in
test.py to 11 seconds, and rerun the test:

## RUNNING TESTS IN PARALLEL

Most modern computers have four or more CPU cores. One fantastic feature of CTest is its
ability to run tests in parallel, if you have more than one core available. This can
significantly reduce the total time to test, and reducing the total test time is what really
counts, to motivate developers to test frequently. In this recipe, we will demonstrate this
feature and discuss how you can optimize the definition of your tests for maximum
performance.

## RUNNING A SUBSET OF THE TESTS 

In the previous recipe, we learned how to run tests in parallel with the help of CMake, and
we discussed that it is advantageous to start with the longest tests. While this strategy
minimizes the total test time, during the code development of a particular feature, or
during debugging, we may not wish to run the entire test set. We may prefer to start with
the longest tests, especially while debugging functionality that is exercised by a short test.
For debugging and code development, we need the ability to only run a selected subset of
tests. In this recipe, we will present strategies to accomplish that.


## INTEGRATED SUPPORT FOR TESTING FRAMEWORKS AND STATIC CODE ANALYSIS

- Support is also provided for the popular GoogleTest framework

- While GoogleTest can be used standalone, CTest can drive the tests defined with the GoogleTest framework, taking over how tests are scheduled to run and the environment they run in.

List of testing frameworks:
  - fdfd
  - fdfd

- CMake also has direct support for a number of popular static code analysis tools

  - clang-tidy
  - cppcheck
  - include-what-you-use 

The above complement tests by providing additional verification of the code quality, adherence to relevant standards and catching common programming models.
Dynamic code analysis is also possible with CMake projects.

## CTEST 

- The CTest is the testing tool used to control how tests execute

- By default, `ctest` will execute all defined tests one at a time, logging a status message as each test is started and completed, but hiding all test output. An overall summary of the tests will be printed at the end.

- Rich features are provided for defining how tests use resources, constraints between tests, and controlling how
tests execute.

- Reporting options include support for a dedicated dashboard server (CDash) or file ouptput in the widely used JUnit XML format.

# The CTest command-line interface

## CTEST 

show a couple of things with the CTest command line interface


## WHAT IS A TARGET

\centering

**GNU Make** 

A target is essentially a recipe that a buildsystem uses to compile a list of files into another file. It can be a `.cpp` implementation file compiled into an `.o` object file, a group of `.o` files packaged into an `.a` static library, and many other combinations.

**CMake**

A target is a logical unit that ...

CMake works on a higher level of abstraction. It understands how to build an executable directly from source files. So, you don't need to write an explicit recipe to compile any object files. All that's required is an `add_executable()` or `add_library` command with the name of the executable target and a list of the files that are to be its elements:

All that's required is to tell CMake about the structure of your project, and it will help you build it. 
We use target to tell CMake about the structure of our project and `target_link_libraries()` to express the dependencies between them.



## OVERVIEW 

<!-- 
    Targets are fundamental concept in CMake

    Next, we'll explain in detail all the steps that the toolchain takes to build a binary artifact from a target. That's the part many books about C++ are missing: how to configure and use preprocessors, compilers, and linkers properly, as well as how to optimize their behavior.

    Lastly, this section will cover all the different ways in which CMake offers to manage dependencies, and will explain how to pick the best one for your specific use case.

    
    Real-world projects require more than compiling a few source files into executables and/or libraries. In the vast majority of cases, you will be faced with projects comprising dozens to hundreds of source files sprawling in a complex source tree. Using modern CMake helps you keep the complexity of the build system in check.

-->

<!-- 
    A CMake target has dependencies and properties.
        1. Executable are targets: add executable
        2.  Libraries are targets: add library
        3. There exist some builtin targets: install, clean, package, . . .
        4.  You may create custom targets: add custom target

In CMake, a target is a core concept that represents a buildable entity within a project. Targets are used to define the final products that CMake generates, such as executables, libraries, or custom commands. Understanding and effectively using targets is crucial for managing complex build systems, especially in larger projects. Hereâ€™s a detailed description of the concept of targets in CMake:

1. Definition of a Target
A target in CMake is essentially a logical unit that encapsulates the settings and dependencies required to build a component of your software project. It can be an executable, a library, or even a custom command.
-->

- With the advent of CMake 3.0, also known as Modern CMake, there has been a significant shift in the way CMake builds should be structured and described. Rather than relying on variables to convey information in a project, we should shift to using **targets** and **properties** allowing for more fine-grained configurations and being less error-prone. (maybe put a link to a good blog post)


- Moder CMake introduced the new concept that "everything is a self-contained target"

- Your application is built as a collection of targets depending on each other.


-->


## MOTIVATION

<!-- 
  BUILDING AND LINKING STATIC AND SHARED LIBRARIES
-->

<!--
  A project almost always consists of more than a single executable built from a single source file. Projects are split across multiple source files, often spread across different subdirectories in the source tree. This practice not only helps in keeping source code organized within a project, but greatly favors modularity, code reuse, and separation of concerns, since common tasks can be grouped into libraries. This separation also simplifies and speeds up recompilation of a project during development. In this recipe, we will show

  how to group sources into libraries and how to link targets against these libraries.

  Keeping everything in one directory is fine for simple projects, but most real world projects split
  their files across multiple directories. It is common to find different file types or individual modules
  grouped under their own directories, or for files belonging to logical functional groupings to be in
  their own part of the projectâ€™s directory hierarchy. While the directory structure may be driven by
  how developers think of the project, the way the project is structured also impacts the build system.

  
WHY USE LIBRARIES IN LARGE-SCALE PROJECTS?
Modularity & Structure:

Organize code into logical entities.
Separate concerns for better readability and maintenance.
Code Reuse:

Share common functionality across multiple targets.
Promote reusability and reduce redundancy.
Efficient Development:

Faster compilation times by isolating changes.
Simplify and speed up the build process.
Maintainability:

Easier to manage, update, and debug large codebases.
Improve overall project structure and scalability.

Mature applications are often built from many components, and I don't mean external dependencies here. Specifically, I'm talking about internal libraries. Adding them to the project is useful from a structural perspective, as related things are packaged together in a single logical entity. And they can be linked with other targets â€“ another library or an executable. This is especially convenient when multiple targets are using the same library.

As software developers, we deliberately draw boundaries and designate components to group one or more units of translation (.cpp files). We do it for multiple reasons: to increase code readability, manage coupling and connascence, speed up the build process, and finally, extract the reusable components.
-->

\vspace{.1cm}

- Large scale projects consist of multiple source files organised in logical components to separate concerns for better readability and maintenance. 
  
\vspace{.5cm}

- In this context, the use of libraries enables:

  Code Reuse

    : Share common functionality across multiple targets.

  Efficient Development
    
    : Faster compilation times by isolating changes.

  Maintainability
    
    : Easier to manage, update, and debug large codebases.

<!-- 
  Why Use Libraries?
    Libraries organize common tasks and reusable code.
    They facilitate modular project structure.
    Libraries improve code maintainability and understanding.

  A project almost always consists of more than a single executable built from a single source file. 
  Only rarely we have one-source-file projects and more realistically, as projects grow, we split them up into separate files. This simplifies (re)compilation but also helps humans maintaining and understanding the project.

  Understanding the concepts that are to come in this chapter helps in organizing 
  and managing larger projects effectively, ensuring better code maintenance and scalability.
-->