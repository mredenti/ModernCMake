---
aspectratio: 169
---

# BASIC STEPS WITH CMAKE

## HELLO WORLD WITH CMAKE!

:::::::::::::: {.columns}
::: {.column width="50%"}

<!--
    The easiest ...
    We wish to compile the following source code into a single executable
-->

\vspace{.5cm}

```c++
//hello.cpp
#include <cstdlib>
#include <iostream>

int main(){
  std::cout << "Hello World!\n";
  return EXIT_SUCCESS;
}
```

. . .

\vspace{.1cm}

<!--
  Alongside the source file, we need to provide CMake with a description of the operations to perform to configure the project for the build tools. The description is done in the CMake language. 
  We will place the CMake instructions into a file called CMakeLists.txt.
  The name of the file is case sensitive;`

  1. Open a text file with your favorite editor. The name of this file will be
  CMakeLists.txt.
  1. The first line sets a minimum required version for CMake. A fatal error will be
  issued if a version of CMake lower than that is used:
  cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
  1. The second line declares the name of the project (recipe-01) and the supported
  language (CXX stands for C++):
  project(recipe-01 LANGUAGES CXX)
  1. We instruct CMake to create a new target: the executable hello-world. This
  executable is generated by compiling and linking the source file helloworld.
  cpp. CMake will use default settings for the compiler and build
  automation tools selected:
    add_executable(hello-world hello-world.cpp)
  and consequently the dependencies <iostream> are automatically linked
  1. Save the file in the same directory as the source file hello-world.cpp.
  Remember that it can only be named CMakeLists.txt.
-->


```{.cmake style=cmakestyle}
# CMakeLists.txt
cmake_minimum_required(VERSION 3.21)

project(HelloWorld LANGUAGES CXX)

add_executable(hello_world hello.cpp)
```

<!-- 
  Configure: Parse the CMakeLists.txt
             Detect toolchains
             Detect architecture
             Find Dependencies
             Generate Cache
  Generate: Write build tool files 
            Write CMakeCache.txt

  Build: Compile binaries
         Link binaries
         Run Tests
         Pack Artifacts
-->

::: 
::: {.column width="50%"}

\vspace{2.5cm}

. . . 

**Generate $\Rightarrow$ Build $\Rightarrow$ Run**

```{.bash style=bashstyle}
$ cmake -B ./build -S ./hello-world

$ cmake --build ./build 

$ ./build/hello_world
```

:::
::::::::::::::

<!--

  The case of CMake commands and variables does not matter: the DSL is case-insensitive. However, the plain-text files that CMake parses must be called CMakeLists.txt and the case matters!

  The -S switch specifies which source directory CMake should scan: this is the folder containing the root CMakeLists.txt, i.e. the one containing the project command. By default, CMake will allow in-source builds, i.e. storing build artifacts alongside source files. This is not good practice: you should always keep build artifacts from sources separate. Fortunately, the -B switch helps with that, as it is used to give where to store build artifacts, including the generated build system.

-->


## CMAKE_MINIMUM_REQUIRED()
  
```{.cmake style=cmakestyle}
cmake_minimum_required(VERSION 3.12)
```

- Every CMake project requires setting the minimally required version(s).

- A fatal error will be issued if a version of CMake lower than the required one is used.


<!-- 
  The CMake language is case insensitive, but the arguments are
  case sensitive

  However, CMake gives no guidance what this version may be, and a lot of projects just take the current CMake version or whatever the IDE is proposing as default. This is a problem, because some platforms don't always provide the latest CMake version, and a lot of trial and error is needed before projects can be used. -> there are tools that can determine the minimal working version of CMake
-->

## PROJECT

<!-- 
  In CMake, C++ is the default programming language. However, we
  suggest to always explicitly state the project’s language in the
  project command using the LANGUAGES option.
-->

- Define the name of the project as well as the supported languages 
  
  ```{.cmake style=cmakestyle}
  project(HelloWorld LANGUAGES CXX)
  ```
  CMake will set various project-specific variables (`PROJECT_NAME`, `PROJECT_SOURCE_DIR`, ...) and determine the compiler(s) based on the specified language(s)

## ADD_EXECUTABLE()

- Add the `hello_world` executable **TARGET** to be built from `hello.cpp`

  ```{.cmake style=cmakestyle}
  add_executable(hello_world hello.cpp)
  ```

<!-- 
  We will encounter the term target repeatedly. In CMake, a target is any object given as first argument to add_executable or add_library. Targets are the basic atom in CMake. Whenever you will need to organize complex projects, think in terms of its targets and their mutual dependencies. The whole family of CMake commands target_* can be used to express chains of dependencies and is much more effective than keeping track of state with variables.

  All the above are built-in commands provided by CMake, part of CMake's internal implementation and one of its core commands.
-->


## GENERATE AND BUILD

<!-- 
  We are now ready to configure the project by creating and stepping into a build
  directory
  
  From the programmer's perspective, using CMake through the CLI is a two step process
-->

Using **CMake** through the CLI is a two-step process:


1. **Generate** the build files 
 
    ```{.bash style=bashstyle}
    $ cmake -B ./build -S ./<path-to-CMakeLists.txt>
    ```

2. Run the **build** system
   
    ```{.bash style=bashstyle}
    $ cmake --build ./build 
    ```

## CMAKE WORKFLOW (Unix Makefiles Generator)

```plantuml

top to bottom direction

skinparam ranksep 5
skinparam padding 0

skinparam artifact {
  BorderColor Black
  BackgroundColor LightGold
  FontSize 10
  StereotypeFontSize 8
}

skinparam file {
  BorderColor Black
}

skinparam rectangle {
  BorderColor Black
  BackgroundColor LightGreen
  roundcorner 25
}

skinparam defaultTextAlignment center
skinparam ArrowColor Black
skinparam Arrow {
  Thickness 1
}

folder "hello-world" as Repo  #LightBlue {
  file "hello_world.cpp" as HelloWorld  #LightGold
  file "CMakeLists.txt" as CMakeLists   #LightGold
}


rectangle "CMake" as CMake {
  rectangle "Configure" as Configure #LightGrey
  rectangle "Generate" as Generate #LightGrey
}

folder "build" as Unix #LightBlue {
  file "CMakeCache.txt" as CMakeCache #LightGold
  file "cmake_install.cmake" as CMakeInstall #LightGold
  folder "CMakeFiles" as CMakeFiles
  file "Makefile" as Makefile #LightGold
}

rectangle "Build" as Build 

' Connect the blocks
CMakeLists -down-> CMake :  1
Configure -right-> Generate
Generate -right-> Unix :  OUT
Unix -down-> Build : 2
```


<!-- 
  The generated `Makefile` assumes "Unix Makefiles" as the underlying host-system build tool
-->



## CMAKE WORKFLOW (Unix Makefiles)

<!-- 
  Running cmake . in the same directory as CMakeLists.txt would in
  principle be enough to configure a project. However, CMake would then
  write all generated files into the root of the project. This would be an insource
  build and is generally undesirable, as it mixes the source and the
  build tree of the project. The out-of-source build we have demonstrated is
  the preferred practice.

  Modularity and Reusability: By using cache variables, the CMake scripts can be made more modular and reusable across different projects and environments without needing to change the script contents themselves.
-->

<!--
  The command invokes CMake through its command-line interface (CLI) and specifies the location of the project's top-level `CMakeLists.txt` file (`-S` option) and target build location (`-B` option) where the host default build system will be generated
-->

On GNU/Linux, CMake will by default generate Unix Makefiles to build the project:

**Makefile**
: The set of instructions that make will run to build the project.

**CMakeFiles**
: Directory which contains temporary files, used by CMake for detecting the operating system, compiler and other project specific files.

**cmake_install.cmake**
: A CMake script handling install rules, which is used at install time. (more on this later)

**CMakeCache.txt**
: A set of key-value cache variables used by CMake when re-running the configuration. (more on this later)


## GENERATED TARGETS

The build system generated by CMake (e.g. Makefile) will contain more targets than those strictly needed for building the executable itself

```{.bash style=bashstyle}
$ cmake --build ./build --target help
... all (the default if no target is provided)
... clean
... depend
... edit_cache
... rebuild_cache
... hello_world
... hello.o
... hello.i
... hello.s
```

and can be chosen individually

```{.bash style=bashstyle}
$ cmake --build ./build --target hello.s
```

<!-- 
  test 
  install 
  package

  For more complex projects, with a test stage and installation rules, CMake will generate
  additional convenience targets:
  test (or RUN_TESTS with the Visual Studio generator) will run the test suite
  with the help of CTest. We will discuss testing and CTest extensively in Chapter
  4, Creating and Running Tests.
  install, will execute the installation rules for the project. We will discuss
  installation rules in Chapter 10, Writing an Installer.

  package, this target will invoke CPack to generate a redistributable package for
  the project. Packaging and CPack will be discussed in Chapter 11, Packaging
  Projects.
-->

## Switching Generators (Ninja)

<!-- 
  CMake is a build system generator and a single CMakeLists.txt can be used to configure projects for different toolstacks on different platforms. 
  You describe in CMakeLists.txt the operations the build system will have to run to get your code configured and compiled.
  Based on these instructions, CMake will generate the corresponding instructions for the chosen build system (Unix Makefiles, Ninja, Visual Studio, and so on).
-->


<!--
  By default, on GNU/Linux and macOS systems, CMake employs the Unix
  Makefiles generator. On Windows, Visual Studio is the default generator

  A single CMakeLists.txt can be used to configure projects for different toolstacks on different platforms. CMake is a build system generator.

  CMake generates the corresponding instructions for the chosen build system.

-->

- For a list of the available generators on your platform inspect the output of

    ```{.bash style=bashstyle}
    $ cmake --help
    ```
 
- To generate Ninja build files, pass the generator explicitly with the `-G` CLI switch

    ```{.bash style=bashstyle}
    $ cmake -G Ninja -S ./<path> -B ./build 
    ```

- The CMake build command wraps the underlying build tool command in a unified, cross-platform interface

    ```{.bash style=bashstyle}
    $ cmake --build ./build 
    ```



# CREATING A LIBRARY 

## ADD_LIBRARY()

- add_library(message STATIC Message.hpp Message.cpp): This will
generate the necessary build tool instructions for compiling the specified sources into a library.


- The first argument to add_library is the name of the target. The
same name can be used throughout CMakeLists.txt to refer to the library. The
actual name of the generated library will be formed by CMake by adding the
prefix lib in front and the appropriate extension as a suffix. The library
extension is determined based on the second argument, STATIC or SHARED, and
the operating system.

- target_link_libraries(hello-world message): Links the library into the
executable. This command will also guarantee that the hello-world executable
properly depends on the message library. We thus ensure that the message
library is always built before we attempt to link it to the hello-world
executable.

- After successful compilation, the build directory will contain the libmessage.a static
library (on GNU/Linux) and the hello-world executable.

## STATIC, SHARED, .

CMake accepts other values as valid for the second argument to add_library and we will
encounter all of them in the rest of the book:
STATIC, which we have already encountered, will be used to create static
libraries, that is, archives of object files for use when linking other targets, such as
executables.
SHARED will be used to create shared libraries, that is, libraries that can be linked
dynamically and loaded at runtime. Switching from a static library to a dynamic
shared object (DSO) is as easy as using add_library(message SHARED
Message.hpp Message.cpp) in CMakeLists.txt.
OBJECT can be used to compile the sources in the list given to add_library to
object files, but then neither archiving them into a static library nor linking them
into a shared object. The use of object libraries is particularly useful if one needs
to create both static and shared libraries in one go. We will demonstrate this in
this recipe.
MODULE libraries are once again DSOs. In contrast to SHARED libraries, they are
not linked to any other target within the project, but may be loaded dynamically
later on. This is the argument to use when building a runtime plugin.

## IMPORTED TARGETS 

CMake is also able to generate special types of libraries. These produce no output in the
build system but are extremely helpful in organizing dependencies and build requirements
between targets:
IMPORTED, this type of library target represents a library located outside the
project. The main use for this type of library is to model pre-existing
dependencies of the project that are provided by upstream packages. As such
IMPORTED libraries are to be treated as immutable. We will show examples of
using IMPORTED libraries throughout the rest of the book. See also: https:/ /
cmake. org/ cmake/ help/ latest/ manual/ cmake- buildsystem. 7. html#importedtargets

INTERFACE, this special type of CMake library is similar to an IMPORTED library,
but is mutable and has no location. Its main use case is to model usage
requirements for a target that is outside our project. We will show a use case for
INTERFACE libraries in Recipe 5, Distributing a project with dependencies as Conda
package, in Chapter 11, Packaging Projects. See also: https:/ / cmake. org/ cmake/
help/ latest/ manual/ cmake- buildsystem. 7. html#interface- libraries
ALIAS, as the name suggests, a library of this type defines an alias for a preexisting
library target within the project. It is thus not possible to choose an alias
for an IMPORTED library. See also: https:/ / cmake. org/ cmake/ help/ latest/
manual/ cmake- buildsystem. 7. html#alias- libraries

# Build Configurations

## Scope 

Targets are visible at any scope after the point that they have been defined. Regular (non-cache) variables are scoped to directories, functions, and block()s, and are only visible to script code in the same directory function, and block scope (same function scope, and same directory level, or subdirectories added by add_subdirectory). To define a variable in the parent directory's scope, you must define it like set(<variable> <value>... PARENT_SCOPE).

## Extra 

In the above example, note that .h header files were specified as sources too, not just the .cpp implementation files. Headers listed as sources don’t get compiled directly on their own, but the effect of adding them is for the benefit of IDE generators like Visual Studio, Xcode, Qt Creator, etc. This causes those headers to be listed in the project’s file list within the IDE, even if no source file refers to it via #include. This can make those headers easier to find during development and potentially aid things like refactoring functionality

## IMPORTANT POINT TO UNDERSTAND - add_subdirectory vs include 

If you need to support CMake 3.12 or older, you will need to either pull up any target_link_libraries() calls to the same directory as the target they operate on, or else use include() rather than add_subdirectory() to avoid introducing a new directory scope. Prefer the former where possible, since it is likely to be more intuitive for developers.

## Motivation 

Build configuration is a critical aspect of software development, particularly in the context of compiled languages such as C, C++, and Fortran. 

Effective build configuration is crucial for several reasons:

Performance: Properly optimized build configurations can significantly improve the performance of the final product.
Portability: Ensures that the software can be built and run on different platforms and environments.
Debugging and Testing: Different configurations can be tailored for more effective debugging and testing.
Reproducibility: Ensures that builds are consistent and reproducible, which is essential for collaborative development and for maintaining stable production environments.

Understanding and managing build configurations is a foundational skill in software engineering, particularly when dealing with complex systems or when targeting multiple platforms. It is about balancing the needs for development efficiency, performance, and maintainability of the codebase.

## Motivation II
Build Configuration often includes:

Compiler Settings:
Choice of Compiler: Determining which compiler (e.g., GCC, Clang, MSVC) is best suited for the project based on platform, performance needs, or specific feature requirements.
Compiler Options: Configuring compiler flags that affect optimization levels, debugging information, and more.
Build Types:
Development Builds: Often have debugging enabled (more verbose logging, no optimization) to facilitate easier tracing of errors and bugs.
Release Builds: Optimized for performance and may include additional changes like disabling logging or assertions to enhance speed and reduce binary size.
Other specialized builds like Test builds (which might include instrumentation for better testing coverage) or Profile builds (used for performance analysis).
Linker Settings:
Static vs. Dynamic Linking: Deciding whether libraries used in the project should be linked statically or dynamically.
Linker Flags: Customizing how the linker behaves, which can affect the final executable's performance and size.
Platform-Specific Configurations:
Tailoring the build process to different operating systems (Linux, Windows, macOS) or even specific versions or distributions of these OSes.
Configuring builds for different hardware architectures (x86, ARM, etc.).
Optimization Settings:
Setting compiler flags that control optimization levels, such as -O2 or -O3 for GCC and Clang, or /O2 for MSVC.
Other optimizations like link time code generation (LTCG) or profile-guided optimizations (PGO).
Environment Variables:
Using environment variables to influence the build process, such as PATH, LD_LIBRARY_PATH, or specific toolchain variables like CC and CXX for defining the C and C++ compilers, respectively.



## Specifying the compiler

<!--

  CMake is aware of the environment and many options can either be
  set via the -D switch of its CLI or via an environment variable. The former
  mechanism overrides the latter, but we suggest to always set options
  explicitly with -D. Explicit is better than implicit, since environment
  variables might be set to values that are not suitable for the project at
  hand.

  We recommend to set the compilers using the -D
  CMAKE_<LANG>_COMPILER CLI options instead of exporting CXX, CC, and
  FC. This is the only way that is guaranteed to be cross-platform and
  compatible with non-POSIX shells. It also avoids polluting your
  environment with variables, which may affect the environment for
  external libraries built together with your project.

-->

CMake stores compilers for each language in the `CMAKE_<LANG>_COMPILER` variable. This variable can be set in one of two ways:

1. By using the `-D` option in the CLI

    ```{.bash style=bashstyle}
    $ module load intel-oneapi-compilers # just mention the path to...
    $ cmake -D CMAKE_CXX_COMPILER=icpp
    ```

2. [Discouraged] By exporting the environment variables `CXX` (`CC`, `FC`, `NVCC`)
   
    ```{.bash style=bashstyle}
    $ env CXX=clang++ cmake ..
    ```

I am not convinced, there should also be a way to set it in the CMakeLists.txt file for instance when I want to use different compilers...

<!--

  How it works
  At configure time, CMake performs a series of platform tests to determine which compilers
  are available and if they are suitable for the project at hand. A suitable compiler is not only
  determined by the platform we are working on, but also by the generator we want to use.
  The first test CMake performs is based on the name of the compiler for the project
  language. For example, if cc is a working C compiler, then that is what will be used as the
  default compiler for a C project. On GNU/Linux, using Unix Makefiles or Ninja, the
  compilers in the GCC family will be most likely chosen by default for C++, C, and Fortran.
  On Microsoft Windows, the C++ and C compilers in Visual Studio will be selected,
  provided Visual Studio is the generator. MinGW compilers are the default if MinGW or
  MSYS Makefiles were chosen as generators.

  DEFAULTS 

  Where can we find which default compilers and compiler flags will be picked up by CMake
  for our platform? CMake offers the --system-information flag, which will dump all
  information about your system to the screen or a file. To see this, try the following:
  $ cmake --system-information information.txt
  Searching through the file (in this case, information.txt), you will find the default
  values for the CMAKE_CXX_COMPILER, CMAKE_C_COMPILER, and
  CMAKE_Fortran_COMPILER options, together with their default flags. We will have a look
  at the flags in the next recipe.

-->

## Extracting compiler information 

```{.cmake style=cmakestyle}
# CMakeLists.txt 
...
message(STATUS "Is the C++ compiler loaded? ${CMAKE_CXX_COMPILER_LOADED}")
if(CMAKE_CXX_COMPILER_LOADED)
  message(STATUS "The C++ compiler ID is: ${CMAKE_CXX_COMPILER_ID}")
  message(STATUS "Is the C++ from GNU? ${CMAKE_COMPILER_IS_GNUCXX}")
  message(STATUS "The C++ compiler version is: ${CMAKE_CXX_COMPILER_VERSION}")
endif()
```

## Switching the build type



## Controlling compiler flags 

## Setting the standard for the language

## CMake Stages


## How it works


# Creating a library

## Making a library


- `main` is both the name of the executable file generated and the name of the **CMake target** created (we will talk about targets in more depth)
- The source file list comes next, and you can list as many as you'd like
- CMake is smart, and will only compile source file extensions. The headers will be, for most intents and purposes, ignored; the only reason to list them is to get them to show up in IDEs


```{.cmake style=cmakestyle}
add_library(one STATIC two.cpp three.h)
```

- You get to pick a type of library, STATIC, SHARED, or MODULE. If you leave this choice off, the value of BUILD_SHARED_LIBS will be used to pick between STATIC and SHARED.


## Try different compilation settings 

- As you'll see in the following sections, often you'll need to make a fictional target, that is, one where nothing needs to be compiled, for example, for a header-only library. That is called an INTERFACE library, and is another choice; the only difference is it cannot be followed by filenames.

- You can also make an ALIAS library with an existing library, which simply gives you a new name for a target. The one benefit to this is that you can make libraries with :: in the name (which you'll see later). 

Before doing this we should re-fresh on the steps involved in the compilation process

- Swapping compilers 
- Pre-processing flags 
- Linking flags 

## Compiler 

CMake may pick the wrong compiler on systems with multiple compilers. You can use the environment variables CC and CXX when you first configure, or CMake variables CMAKE_CXX_COMPILER, etc. - but you need to pick the compiler on the first run; you can’t just reconfigure to get a new compiler.

## Setting compiler options 

## Using different compilers 

## {.standout}

Exercise. Configure a project to use a different compiler.

## Managing build types


## {.standout}

Exercise. Modify the CMake project to support multiple build types