---
aspectratio: 169
---

# BASIC STEPS WITH CMAKE

## HELLO, WORLD!

\lstset{
  xleftmargin=0.0\linewidth,
  xrightmargin=0.0\linewidth
}

:::::::::::::: {.columns}
::: {.column width="45%"}

\vspace{.5cm}

**CPP**

```c++
//hello.cpp
#include <cstdlib>
#include <iostream>

int main(){

  std::cout << "Hello, World!\n";
  
  return EXIT_SUCCESS;
}
```

::: 
::: {.column width="45%"}

\vspace{.5cm}

**FORTRAN**

```fortran
! hello.F90

program hello

  implicit none

  print *, 'Hello, World!'

end program hello
 
```

::: 
::::::::::::::

## ## MANUAL COMPILATION OF HELLO, WORLD!

:::::::::::::: {.columns}
::: {.column width="50%"}

\vspace{.5cm}

**CPP**

\vspace{.2cm}

Step 1: Compile object file

```{.shell style=bashstyle}
g++ -c hello.cpp -o hello.o
```

\vspace{.2cm}

Step 2: Link object file to create executable

```{.shell style=bashstyle}
g++ hello.o -o hello
```

::: 
::: {.column width="50%"}

\vspace{.5cm}

**FORTRAN**

\vspace{.2cm}

Step 1: Compile object file

```{.shell style=bashstyle}
gfortran -c hello.cpp -o hello.o
```

\vspace{.2cm}

Step 2: Link object file to create executable

```{.shell style=bashstyle}
gfortran hello.o -o hello
```


::: 
::::::::::::::


## HELLO, WORLD! WITH CMAKE

<!--
  Alongside the source file, we need to provide CMake with a description of the operations to perform to configure the project for the build tools. The description is done in the CMake language. 
  We will place the CMake instructions into a file called CMakeLists.txt.
  The name of the file is case sensitive;`

  1. Open a text file with your favorite editor. The name of this file will be
  CMakeLists.txt.
  1. The first line sets a minimum required version for CMake. A fatal error will be
  issued if a version of CMake lower than that is used:
  cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
  1. The second line declares the name of the project (recipe-01) and the supported
  language (CXX stands for C++):
  project(recipe-01 LANGUAGES CXX)
  1. We instruct CMake to create a new target: the executable hello-world. This
  executable is generated by compiling and linking the source file helloworld.
  cpp. CMake will use default settings for the compiler and build
  automation tools selected:
    add_executable(hello-world hello-world.cpp)
  and consequently the dependencies <iostream> are automatically linked
  1. Save the file in the same directory as the source file hello-world.cpp.
  Remember that it can only be named CMakeLists.txt.
-->

\vspace{.3cm}

\centering

The root of a project using CMake must contain a **CMakeLists.txt** file.

:::::::::::::: {.columns}
::: {.column width="50%"}

\vspace{.4cm}

**CPP**

```{.cmake style=cmakestyle}
cmake_minimum_required(VERSION 3.21)

project(HelloWorld LANGUAGES CXX)

add_executable(hello hello.cpp)
```

<!--

  The case of CMake commands and variables does not matter: the DSL is case-insensitive. However, the plain-text files that CMake parses must be called CMakeLists.txt and the case matters!

  The -S switch specifies which source directory CMake should scan: this is the folder containing the root CMakeLists.txt, i.e. the one containing the project command. By default, CMake will allow in-source builds, i.e. storing build artifacts alongside source files. This is not good practice: you should always keep build artifacts from sources separate. Fortunately, the -B switch helps with that, as it is used to give where to store build artifacts, including the generated build system.

-->

\begin{forest}
  pic dir tree,
  where level=0{}{
    directory,
  },
  [ 
    [hello-world
      [\colorbox{pink}{CMakeLists.txt}, file
      ]
      [hello.cpp, file
      ]
    ]
  ]
\end{forest}

::: 
::: {.column width="50%"}

\vspace{.4cm}

**FORTRAN**

```{.cmake style=cmakestyle}
cmake_minimum_required(VERSION 3.21)

project(HelloWorld LANGUAGES Fortran)

add_executable(hello hello.F90)
```

\begin{forest}
  pic dir tree,
  where level=0{}{
    directory,
  },
  [ 
    [hello-world
      [\colorbox{pink}{CMakeLists.txt}, file
      ]
      [hello.F90, file
      ]
    ]
  ]
\end{forest}

::: 
::::::::::::::

<!-- 
  Configure: Parse the CMakeLists.txt
             Detect toolchains
             Detect architecture
             Find Dependencies
             Generate Cache
  Generate: Write build tool files 
            Write CMakeCache.txt

  Build: Compile binaries
         Link binaries
         Run Tests
         Pack Artifacts
-->

## CMAKE_MINIMUM_REQUIRED()

<!-- 
  Purpose: Ensures the project uses a minimum version of CMake for compatibility. 
-->
  
```{.cmake style=cmakestyle}
cmake_minimum_required(VERSION <min>)
```

- Every CMake project requires setting the minimally required version(s) as the first line of the root **CMakeLists.txt** file.

- CMake will stop processing and a fatal error will be issued if the running version of CMake is lower than the `<min>` required.

<!--
  Which version should you set? Don't worry about it, there are tools that automatically test your project to determine the minimum CMake version required.
-->

<!-- 
  The CMake language is case insensitive, but the arguments are
  case sensitive

  However, CMake gives no guidance what this version may be, and a lot of projects just take the current CMake version or whatever the IDE is proposing as default. This is a problem, because some platforms don't always provide the latest CMake version, and a lot of trial and error is needed before projects can be used. -> there are tools that can determine the minimal working version of CMake
-->

## PROJECT()

<!-- 
  In CMake, C++ is the default programming language. However, we
  suggest to always explicitly state the project’s language in the
  project command using the LANGUAGES option.
-->

  
```{.cmake style=cmakestyle}
project(<name>
        [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]
        [DESCRIPTION <description-string>]
        [HOMEPAGE_URL <url-string>]
        [LANGUAGES <language-name>...])
```

<!-- 
  Defines the project name and sets up the environment for building
-->

- Initializes various project-level settings, variables (`PROJECT_NAME`, `PROJECT_SOURCE_DIR`, ...) and the languages enabled for the build

- Invocation of the `project()` command triggers a series of internal **Modules** inclusion that:
  - Determine Operating System Information (`CMakeDetermineSystem.cmake`, ...)
  - Find and Test Compilers (`CMakeDetermineCXXCompiler.cmake`, `CMakeCXXCompiler.cmake`, .)

- Multiple languages can be enabled (C, C++, Fortran, C#, CUDA, ...) 

<!--
  CMakeDetermineCXXCompiler.cmake: Determines the C++ compiler to use.
  CMakeCXXCompiler.cmake: Sets up the compiler flags and other configurations specific to the C++ compiler.
  CMakeCXXInformation.cmake: Sets up C++ specific information, such as default include directories and standard flags.
-->

## ADD_EXECUTABLE()

```{.cmake style=cmakestyle}
add_executable(<name>
                [EXCLUDE_FROM_ALL]
                [source1] [source2 ...]) 
```

- Creates the `<name>` executable **TARGET** to be built from the source files `source1, source, ...`

<!--

- `main` is both the name of the executable file generated and the name of the **CMake target** created (we will talk about targets in more depth)
- The source file list comes next, and you can list as many as you'd like
- CMake is smart, and will only compile source file extensions. The headers will be, for most intents and purposes, ignored; the only reason to list them is to get them to show up in IDEs
  The simple example given previously required defining a target name for the executable
and listing the source files to be compiled

We will encounter the term target repeatedly. In CMake, a target is any object given as first argument to add_executable or add_library. Targets are the basic atom in CMake. Whenever you will need to organize complex projects, think in terms of its targets and their mutual dependencies. The whole family of CMake commands target_* can be used to express chains of dependencies and is much more effective than keeping track of state with variables. 

In the above example, note that .h header files were specified as sources too, not just the .cpp implementation files. Headers listed as sources don’t get compiled directly on their own, but the effect of adding them is for the benefit of IDE generators like Visual Studio, Xcode, Qt Creator, etc. This causes those headers to be listed in the project’s file list within the IDE, even if no source file refers to it via #include. This can make those headers easier to find during development and potentially aid things like refactoring functionality
s.
-->

- Known extensions to CMake:
  
  **C** 
    : .c .C \text{ } .h
  
  **CXX**
    : .c++ .cc .cpp .cxx \text{ } .hpp .h++ .hxx
  
  **Fortran**
    : .f .F .f77 .f90 .f95 .f03 .F90

<!-- 
  We will encounter the term target repeatedly. In CMake, a target is any object given as first argument to add_executable or add_library. Targets are the basic atom in CMake. Whenever you will need to organize complex projects, think in terms of its targets and their mutual dependencies. The whole family of CMake commands target_* can be used to express chains of dependencies and is much more effective than keeping track of state with variables.

  All the above are built-in commands provided by CMake, part of CMake's internal implementation and one of its core commands.
-->

## RUNNING CMAKE 

`cmake`
  : a non-interactive CL

`ccmake`
  : a curse-based TUI

`cmake-gui` 
  : a QT-based GUI
  
<!-- 
  put some pictures instead on the side of the UI
-->

. . . 

\vspace{.5cm}

On Galileo100

  ```{.bash style=bashstyle}
  $ module load cmake/3.21.4
  $ ls $CMAKE_PREFIX_PATH/bin
  ccmake  cmake  cpack  ctest
  ```

## STEP 1 - BUILD FILES GENERATION

\centering The first step with **cmake** is to **generate project files**.

<!--
  This involves running the cmake command to configure the project and generate the necessary build system files.

  Use the cmake command to configure the project and generate the build system files in the build directory. The -S flag specifies the source directory (where your CMakeLists.txt file is located), and the -B flag specifies the build directory.

  Configure the project by detecting your system's compiler and other necessary tools.

  Generate build system files in the build directory (e.g., Makefiles or project files for your IDE).

  The first step with CMake after writing your source files and CMakeLists.txt is to generate project files by running the cmake command with the source and build directory specifications. This prepares your project for building by creating all necessary build system files.
-->

\vspace{.5cm}

:::::::::::::: {.columns}
::: {.column width="75%"}

  ```{.bash style=bashstyle}
  $ cmake -B ./build -S ./hello-world
  -- The CXX compiler identification is GNU 8.4.1
  -- Detecting CXX compiler ABI info
  -- Detecting CXX compiler ABI info - done
  -- Check for working CXX compiler: /usr/bin/c++ 
    - skipped
  -- Detecting CXX compile features
  -- Detecting CXX compile features - done
  -- Configuring done (0.9s)
  -- Generating done (0.1s)
  -- Build files have been written to: <...>/build
  ```

::: 
::: {.column width="25%"}

\begin{forest}
  pic dir tree,
  where level=0{}{
    directory,
  },
  [ 
    [hello-world
      [CMakeLists.txt, file
      ]
      [hello.cpp, file
      ]
    ]
  ]
\end{forest}

:::
::::::::::::::


## STEP 1 - BUILD FILES GENERATION (Cont.)

:::::::::::::: {.columns}
::: {.column width="65%"}

\vspace{1cm}

- **Unix Makefiles** is the default CMake generator on G100

\vspace{.5cm}

- The developer must **never edit the generated files**
<!-- 
  The developer edits the CMakeLists.txt, invoke CMake but must never edit the generated files
-->

\vspace{.5cm}

- **Out of source builds!** 
  - clear separation of source and build files
  
  - several build trees for the same source tree
  
  - safe to delete the build tree in order to do a clean build

<!--
  The number of active generators depends on the platform we are
  running on Unix, Apple, Windows
-->

::: 
::: {.column width="35%"}

\begin{forest}
  pic dir tree,
  where level=0{}{
    directory,
  },
  [ 
    [hello-world
      [CMakeLists.txt, file
      ]
      [hello.cpp, file
      ]
    ]
    [build
      [CMakeCache.txt, file
      ]
      [CMakeFiles
      ]
      [Makefile, file
      ]
      [cmake\_install.cmake, file
      ]
    ]
  ]
\end{forest}

::: 
::::::::::::::

## STEP 1 - BUILD FILES GENERATION (Cont.)

<!-- 
  Running cmake . in the same directory as CMakeLists.txt would in
  principle be enough to configure a project. However, CMake would then
  write all generated files into the root of the project. This would be an insource
  build and is generally undesirable, as it mixes the source and the
  build tree of the project. The out-of-source build we have demonstrated is
  the preferred practice.

  Modularity and Reusability: By using cache variables, the CMake scripts can be made more modular and reusable across different projects and environments without needing to change the script contents themselves.
-->

<!--
  The command invokes CMake through its command-line interface (CLI) and specifies the location of the project's top-level `CMakeLists.txt` file (`-S` option) and target build location (`-B` option) where the host default build system will be generated
-->

On GNU/Linux, CMake will by default generate Unix Makefiles to build the project:

**Makefile**
: The set of instructions that make will run to build the project.

**CMakeFiles**
: Directory which contains temporary files, used by CMake for detecting the operating system, compiler and other project specific files.

**cmake_install.cmake**
: A CMake script handling install rules, which is used at install time. (more on this later)

**CMakeCache.txt**
: A set of key-value cache variables used by CMake when re-running the configuration. (more on this later)

<!-- 
  test 
  install 
  package

  For more complex projects, with a test stage and installation rules, CMake will generate
  additional convenience targets:
  test (or RUN_TESTS with the Visual Studio generator) will run the test suite
  with the help of CTest. We will discuss testing and CTest extensively in Chapter
  4, Creating and Running Tests.
  install, will execute the installation rules for the project. We will discuss
  installation rules in Chapter 10, Writing an Installer.

  package, this target will invoke CPack to generate a redistributable package for
  the project. Packaging and CPack will be discussed in Chapter 11, Packaging
  Projects.
-->

## STEP 2 - RUNNING THE NATIVE BUILD SYSTEM

<!--
  Abstracting away the build tool
    CMake also comes to our aid in helping us not have to deal with the platform differences of the build tool. The cmake --build option directs CMake to invoke the appropriate build tool for us, which allows us to specify the whole build something like this:
-->

\centering Once the project files have been generated, we direct CMake to invoke the appropriate build tool.

\vspace{.3cm}

```{.bash style=bashstyle}
$ cmake --build ./build 
[ 50%] Building CXX object CMakeFiles/hello.dir/hello.cpp.o
[100%] Linking CXX executable hello
[100%] Built target hello
``` 

<!-- 

  The `--build` flag will automatically invoke the native build tool
-->

. . . 

- [Not recommended] If the generator is **Unix Makefiles** the following is equivalent

  ```{.bash style=bashstyle}
  $ cd build && make all
  ```

- The former way is “better” because it is less tied to a specific build tool (portability - writing documentation, CI/CD pipelines, ...)


## STEP 2 - RUNNING THE NATIVE BUILD SYSTEM (VERBOSE MODE)

To see the output in verbose mode append the `--verbose` flag 

  ```{.bash style=bashstyle}
  $ cmake --build ./build --verbose
  . . .
  [ 50%] Building CXX object CMakeFiles/hello.dir/hello.cpp.o
  /usr/bin/c++    
    -MD -MT CMakeFiles/hello.dir/hello.cpp.o 
    -MF CMakeFiles/hello.dir/hello.cpp.o.d 
    -o CMakeFiles/hello.dir/hello.cpp.o 
    -c <...>/HelloWorld/hello.cpp
  [100%] Linking CXX executable hello
  . . .
  /usr/bin/c++ CMakeFiles/hello.dir/hello.cpp.o -o hello 
  . . .
  ```

## STEP 3 - RUN THE HELLO WORLD

:::::::::::::: {.columns}
::: {.column width="65%"}

\vspace{1cm}

```{.bash style=bashstyle}
$ ./build/hello
Hello, World!
```

<!--
  The number of active generators depends on the platform we are
  running on Unix, Apple, Windows
-->

::: 
::: {.column width="35%"}

\begin{forest}
  pic dir tree,
  where level=0{}{
    directory,
  },
  [ 
    [hello-world
      [CMakeLists.txt, file
      ]
      [hello.cpp, file
      ]
    ]
    [build
      [CMakeCache.txt, file
      ]
      [CMakeFiles
      ]
      [Makefile, file
      ]
      [cmake\_install.cmake, file
      ]
      [hello, executable
      ]
    ]
  ]
\end{forest}

::: 
::::::::::::::


## GENERATED TARGETS

The build system files generated by CMake (e.g. Makefile) will contain more targets than those strictly needed for building the executable itself

```{.bash style=bashstyle}
$ cmake --build ./build --target help
... all (the default if no target is provided)
... clean
... depend
... edit_cache
... rebuild_cache
... hello
... hello.o
... hello.i
... hello.s
```

and each target can be invoked individually

```{.bash style=bashstyle}
$ cmake --build ./build --target hello
```

## SWITCHING GENERATORS 

<!-- 
  CMake is a build system generator and a single CMakeLists.txt can be used to configure projects for different toolstacks on different platforms. 
  You describe in CMakeLists.txt the operations the build system will have to run to get your code configured and compiled.
  Based on these instructions, CMake will generate the corresponding instructions for the chosen build system (Unix Makefiles, Ninja, Visual Studio, and so on).
-->


<!--
  By default, on GNU/Linux and macOS systems, CMake employs the Unix
  Makefiles generator. On Windows, Visual Studio is the default generator

  A single CMakeLists.txt can be used to configure projects for different toolstacks on different platforms. CMake is a build system generator.

  CMake generates the corresponding instructions for the chosen build system.

-->

\vspace{.2cm}

- For a list of the available generators on your platform inspect the output of

    ```{.bash style=bashstyle}
    $ cmake --help
    . . .
    Generators

    The following generators are available on this platform 
    (* marks default):
    
    * Unix Makefiles           = Generates standard UNIX makefiles.
      Ninja                    = Generates build.ninja files.
    . . . 
    ```
 
- To generate Ninja build files, pass the generator explicitly with the `-G` CLI switch

    ```{.bash style=bashstyle}
    $ cmake -G Ninja -S ./<> -B ./build 
    ```

<!--
  The CMake build command wraps the underlying build tool command in a unified, cross-platform interface

    ```{.bash style=bashstyle}
    $ cmake --build ./build 
    ```
-->

## (CONFIGURE $\Rightarrow$ GENERATE) $\Rightarrow$ BUILD $\Rightarrow$ RUN

<!-- 
  From the programmer's perspective, using CMake through the CLI is a two step process
-->

1. **Generate** the build files 
 
    ```{.bash style=bashstyle}
    $ cmake -B ./build -S <path-to-root-CMakeLists.txt>
    ```

2. Run the native **build** system (compile)
   
    ```{.bash style=bashstyle}
    $ cmake --build ./build 
    ```

3. Run the `hello` program

   ```{.bash style=bashstyle}
    $ ./build/hello
    ```

## CONFIGURE $\Rightarrow$ GENERATE $\Rightarrow$ BUILD $\Rightarrow$ RUN


- oik 

Maybe show how using ccmake it is actually two distinct steps... maybe on the screen interactively


<!--
fd
-->